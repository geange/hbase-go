// Autogenerated by Thrift Compiler (0.9.3)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package v2

import (
	"bytes"
	"fmt"
	"git.apache.org/thrift.git/lib/go/thrift"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = bytes.Equal

type THBaseService interface {
	// Test for the existence of columns in the table, as specified in the TGet.
	//
	// @return true if the specified TGet matches one or more keys, false if not
	//
	// Parameters:
	//  - Table: the table to check on
	//  - Tget: the TGet to check for
	Exists(table []byte, tget *TGet) (r bool, err error)
	// Test for the existence of columns in the table, as specified by the TGets.
	//
	// This will return an array of booleans. Each value will be true if the related Get matches
	// one or more keys, false if not.
	//
	// Parameters:
	//  - Table: the table to check on
	//  - Tgets: a list of TGets to check for
	ExistsAll(table []byte, tgets []*TGet) (r []bool, err error)
	// Method for getting data from a row.
	//
	// If the row cannot be found an empty Result is returned.
	// This can be checked by the empty field of the TResult
	//
	// @return the result
	//
	// Parameters:
	//  - Table: the table to get from
	//  - Tget: the TGet to fetch
	Get(table []byte, tget *TGet) (r *TResult_, err error)
	// Method for getting multiple rows.
	//
	// If a row cannot be found there will be a null
	// value in the result list for that TGet at the
	// same position.
	//
	// So the Results are in the same order as the TGets.
	//
	// Parameters:
	//  - Table: the table to get from
	//  - Tgets: a list of TGets to fetch, the Result list
	// will have the Results at corresponding positions
	// or null if there was an error
	GetMultiple(table []byte, tgets []*TGet) (r []*TResult_, err error)
	// Commit a TPut to a table.
	//
	// Parameters:
	//  - Table: the table to put data in
	//  - Tput: the TPut to put
	Put(table []byte, tput *TPut) (err error)
	// Atomically checks if a row/family/qualifier value matches the expected
	// value. If it does, it adds the TPut.
	//
	// @return true if the new put was executed, false otherwise
	//
	// Parameters:
	//  - Table: to check in and put to
	//  - Row: row to check
	//  - Family: column family to check
	//  - Qualifier: column qualifier to check
	//  - Value: the expected value, if not provided the
	// check is for the non-existence of the
	// column in question
	//  - Tput: the TPut to put if the check succeeds
	CheckAndPut(table []byte, row []byte, family []byte, qualifier []byte, value []byte, tput *TPut) (r bool, err error)
	// Commit a List of Puts to the table.
	//
	// Parameters:
	//  - Table: the table to put data in
	//  - Tputs: a list of TPuts to commit
	PutMultiple(table []byte, tputs []*TPut) (err error)
	// Deletes as specified by the TDelete.
	//
	// Note: "delete" is a reserved keyword and cannot be used in Thrift
	// thus the inconsistent naming scheme from the other functions.
	//
	// Parameters:
	//  - Table: the table to delete from
	//  - Tdelete: the TDelete to delete
	DeleteSingle(table []byte, tdelete *TDelete) (err error)
	// Bulk commit a List of TDeletes to the table.
	//
	// Throws a TIOError if any of the deletes fail.
	//
	// Always returns an empty list for backwards compatibility.
	//
	// Parameters:
	//  - Table: the table to delete from
	//  - Tdeletes: list of TDeletes to delete
	DeleteMultiple(table []byte, tdeletes []*TDelete) (r []*TDelete, err error)
	// Atomically checks if a row/family/qualifier value matches the expected
	// value. If it does, it adds the delete.
	//
	// @return true if the new delete was executed, false otherwise
	//
	// Parameters:
	//  - Table: to check in and delete from
	//  - Row: row to check
	//  - Family: column family to check
	//  - Qualifier: column qualifier to check
	//  - Value: the expected value, if not provided the
	// check is for the non-existence of the
	// column in question
	//  - Tdelete: the TDelete to execute if the check succeeds
	CheckAndDelete(table []byte, row []byte, family []byte, qualifier []byte, value []byte, tdelete *TDelete) (r bool, err error)
	// Parameters:
	//  - Table: the table to increment the value on
	//  - Tincrement: the TIncrement to increment
	Increment(table []byte, tincrement *TIncrement) (r *TResult_, err error)
	// Parameters:
	//  - Table: the table to append the value on
	//  - Tappend: the TAppend to append
	Append(table []byte, tappend *TAppend) (r *TResult_, err error)
	// Get a Scanner for the provided TScan object.
	//
	// @return Scanner Id to be used with other scanner procedures
	//
	// Parameters:
	//  - Table: the table to get the Scanner for
	//  - Tscan: the scan object to get a Scanner for
	OpenScanner(table []byte, tscan *TScan) (r int32, err error)
	// Grabs multiple rows from a Scanner.
	//
	// @return Between zero and numRows TResults
	//
	// Parameters:
	//  - ScannerId: the Id of the Scanner to return rows from. This is an Id returned from the openScanner function.
	//  - NumRows: number of rows to return
	GetScannerRows(scannerId int32, numRows int32) (r []*TResult_, err error)
	// Closes the scanner. Should be called to free server side resources timely.
	// Typically close once the scanner is not needed anymore, i.e. after looping
	// over it to get all the required rows.
	//
	// Parameters:
	//  - ScannerId: the Id of the Scanner to close *
	CloseScanner(scannerId int32) (err error)
	// mutateRow performs multiple mutations atomically on a single row.
	//
	// Parameters:
	//  - Table: table to apply the mutations
	//  - TrowMutations: mutations to apply
	MutateRow(table []byte, trowMutations *TRowMutations) (err error)
	// Get results for the provided TScan object.
	// This helper function opens a scanner, get the results and close the scanner.
	//
	// @return between zero and numRows TResults
	//
	// Parameters:
	//  - Table: the table to get the Scanner for
	//  - Tscan: the scan object to get a Scanner for
	//  - NumRows: number of rows to return
	GetScannerResults(table []byte, tscan *TScan, numRows int32) (r []*TResult_, err error)
	// Given a table and a row get the location of the region that
	// would contain the given row key.
	//
	// reload = true means the cache will be cleared and the location
	// will be fetched from meta.
	//
	// Parameters:
	//  - Table
	//  - Row
	//  - Reload
	GetRegionLocation(table []byte, row []byte, reload bool) (r *THRegionLocation, err error)
	// Get all of the region locations for a given table.
	//
	//
	// Parameters:
	//  - Table
	GetAllRegionLocations(table []byte) (r []*THRegionLocation, err error)
	// Atomically checks if a row/family/qualifier value matches the expected
	// value. If it does, it mutates the row.
	//
	// @return true if the row was mutated, false otherwise
	//
	// Parameters:
	//  - Table: to check in and delete from
	//  - Row: row to check
	//  - Family: column family to check
	//  - Qualifier: column qualifier to check
	//  - CompareOp: comparison to make on the value
	//  - Value: the expected value to be compared against, if not provided the
	// check is for the non-existence of the column in question
	//  - RowMutations: row mutations to execute if the value matches
	CheckAndMutate(table []byte, row []byte, family []byte, qualifier []byte, compareOp TCompareOp, value []byte, rowMutations *TRowMutations) (r bool, err error)
	// Get a table descriptor.
	// @return the TableDescriptor of the giving tablename
	//
	//
	// Parameters:
	//  - Table: the tablename of the table to get tableDescriptor
	GetTableDescriptor(table *TTableName) (r *TTableDescriptor, err error)
	// Get table descriptors of tables.
	// @return the TableDescriptor of the giving tablename
	//
	//
	// Parameters:
	//  - Tables: the tablename list of the tables to get tableDescriptor
	GetTableDescriptors(tables []*TTableName) (r []*TTableDescriptor, err error)
	//
	// @return true if table exists already, false if not
	//
	//
	// Parameters:
	//  - TableName: the tablename of the tables to check
	TableExists(tableName *TTableName) (r bool, err error)
	// Get table descriptors of tables that match the given pattern
	// @return the tableDescriptors of the matching table
	//
	//
	// Parameters:
	//  - Regex: The regular expression to match against
	//  - IncludeSysTables: set to false if match only against userspace tables
	GetTableDescriptorsByPattern(regex string, includeSysTables bool) (r []*TTableDescriptor, err error)
	// Get table descriptors of tables in the given namespace
	// @return the tableDescriptors in the namespce
	//
	//
	// Parameters:
	//  - Name: The namesapce's name
	GetTableDescriptorsByNamespace(name string) (r []*TTableDescriptor, err error)
	// Get table names of tables that match the given pattern
	// @return the table names of the matching table
	//
	//
	// Parameters:
	//  - Regex: The regular expression to match against
	//  - IncludeSysTables: set to false if match only against userspace tables
	GetTableNamesByPattern(regex string, includeSysTables bool) (r []*TTableName, err error)
	// Get table names of tables in the given namespace
	// @return the table names of the matching table
	//
	//
	// Parameters:
	//  - Name: The namesapce's name
	GetTableNamesByNamespace(name string) (r []*TTableName, err error)
	// Creates a new table with an initial set of empty regions defined by the specified split keys.
	// The total number of regions created will be the number of split keys plus one. Synchronous
	// operation.
	//
	//
	// Parameters:
	//  - Desc: table descriptor for table
	//  - SplitKeys: rray of split keys for the initial regions of the table
	CreateTable(desc *TTableDescriptor, splitKeys [][]byte) (err error)
	// Deletes a table. Synchronous operation.
	//
	//
	// Parameters:
	//  - TableName: the tablename to delete
	DeleteTable(tableName *TTableName) (err error)
	// Truncate a table. Synchronous operation.
	//
	//
	// Parameters:
	//  - TableName: the tablename to truncate
	//  - PreserveSplits: whether to  preserve previous splits
	TruncateTable(tableName *TTableName, preserveSplits bool) (err error)
	// Enalbe a table
	//
	//
	// Parameters:
	//  - TableName: the tablename to enable
	EnableTable(tableName *TTableName) (err error)
	// Disable a table
	//
	//
	// Parameters:
	//  - TableName: the tablename to disable
	DisableTable(tableName *TTableName) (err error)
	//
	// @return true if table is enabled, false if not
	//
	//
	// Parameters:
	//  - TableName: the tablename to check
	IsTableEnabled(tableName *TTableName) (r bool, err error)
	//
	// @return true if table is disabled, false if not
	//
	//
	// Parameters:
	//  - TableName: the tablename to check
	IsTableDisabled(tableName *TTableName) (r bool, err error)
	//
	// @return true if table is available, false if not
	//
	//
	// Parameters:
	//  - TableName: the tablename to check
	IsTableAvailable(tableName *TTableName) (r bool, err error)
	//  * Use this api to check if the table has been created with the specified number of splitkeys
	//  * which was used while creating the given table. Note : If this api is used after a table's
	//  * region gets splitted, the api may return false.
	//  *
	//  * @return true if table is available, false if not
	//  *
	//  * @deprecated Since 2.2.0. Because the same method in Table interface has been deprecated
	//  * since 2.0.0, we will remove it in 3.0.0 release.
	//  * Use {@link #isTableAvailable(TTableName tableName)} instead
	// *
	//
	// Parameters:
	//  - TableName: the tablename to check
	//  - SplitKeys: keys to check if the table has been created with all split keys
	IsTableAvailableWithSplit(tableName *TTableName, splitKeys [][]byte) (r bool, err error)
	// Add a column family to an existing table. Synchronous operation.
	//
	//
	// Parameters:
	//  - TableName: the tablename to add column family to
	//  - Column: column family descriptor of column family to be added
	AddColumnFamily(tableName *TTableName, column *TColumnFamilyDescriptor) (err error)
	// Delete a column family from a table. Synchronous operation.
	//
	//
	// Parameters:
	//  - TableName: the tablename to delete column family from
	//  - Column: name of column family to be deleted
	DeleteColumnFamily(tableName *TTableName, column []byte) (err error)
	// Modify an existing column family on a table. Synchronous operation.
	//
	//
	// Parameters:
	//  - TableName: the tablename to modify column family
	//  - Column: column family descriptor of column family to be modified
	ModifyColumnFamily(tableName *TTableName, column *TColumnFamilyDescriptor) (err error)
	// Modify an existing table
	//
	//
	// Parameters:
	//  - Desc: the descriptor of the table to modify
	ModifyTable(desc *TTableDescriptor) (err error)
	// Create a new namespace. Blocks until namespace has been successfully created or an exception is
	// thrown
	//
	//
	// Parameters:
	//  - NamespaceDesc: descriptor which describes the new namespace
	CreateNamespace(namespaceDesc *TNamespaceDescriptor) (err error)
	// Modify an existing namespace.  Blocks until namespace has been successfully modified or an
	// exception is thrown
	//
	//
	// Parameters:
	//  - NamespaceDesc: descriptor which describes the new namespace
	ModifyNamespace(namespaceDesc *TNamespaceDescriptor) (err error)
	// Delete an existing namespace. Only empty namespaces (no tables) can be removed.
	// Blocks until namespace has been successfully deleted or an
	// exception is thrown.
	//
	//
	// Parameters:
	//  - Name: namespace name
	DeleteNamespace(name string) (err error)
	// Get a namespace descriptor by name.
	// @retrun the descriptor
	//
	//
	// Parameters:
	//  - Name: name of namespace descriptor
	GetNamespaceDescriptor(name string) (r *TNamespaceDescriptor, err error)
	// @return all namespaces
	//
	ListNamespaceDescriptors() (r []*TNamespaceDescriptor, err error)
}

type THBaseServiceClient struct {
	Transport       thrift.TTransport
	ProtocolFactory thrift.TProtocolFactory
	InputProtocol   thrift.TProtocol
	OutputProtocol  thrift.TProtocol
	SeqId           int32
}

func NewTHBaseServiceClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *THBaseServiceClient {
	return &THBaseServiceClient{Transport: t,
		ProtocolFactory: f,
		InputProtocol:   f.GetProtocol(t),
		OutputProtocol:  f.GetProtocol(t),
		SeqId:           0,
	}
}

func NewTHBaseServiceClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *THBaseServiceClient {
	return &THBaseServiceClient{Transport: t,
		ProtocolFactory: nil,
		InputProtocol:   iprot,
		OutputProtocol:  oprot,
		SeqId:           0,
	}
}

// Test for the existence of columns in the table, as specified in the TGet.
//
// @return true if the specified TGet matches one or more keys, false if not
//
// Parameters:
//  - Table: the table to check on
//  - Tget: the TGet to check for
func (p *THBaseServiceClient) Exists(table []byte, tget *TGet) (r bool, err error) {
	if err = p.sendExists(table, tget); err != nil {
		return
	}
	return p.recvExists()
}

func (p *THBaseServiceClient) sendExists(table []byte, tget *TGet) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("exists", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := THBaseServiceExistsArgs{
		Table: table,
		Tget:  tget,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvExists() (value bool, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "exists" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "exists failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "exists failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error32 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error33 error
		error33, err = error32.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error33
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "exists failed: invalid message type")
		return
	}
	result := THBaseServiceExistsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Test for the existence of columns in the table, as specified by the TGets.
//
// This will return an array of booleans. Each value will be true if the related Get matches
// one or more keys, false if not.
//
// Parameters:
//  - Table: the table to check on
//  - Tgets: a list of TGets to check for
func (p *THBaseServiceClient) ExistsAll(table []byte, tgets []*TGet) (r []bool, err error) {
	if err = p.sendExistsAll(table, tgets); err != nil {
		return
	}
	return p.recvExistsAll()
}

func (p *THBaseServiceClient) sendExistsAll(table []byte, tgets []*TGet) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("existsAll", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := THBaseServiceExistsAllArgs{
		Table: table,
		Tgets: tgets,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvExistsAll() (value []bool, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "existsAll" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "existsAll failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "existsAll failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error34 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error35 error
		error35, err = error34.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error35
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "existsAll failed: invalid message type")
		return
	}
	result := THBaseServiceExistsAllResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Method for getting data from a row.
//
// If the row cannot be found an empty Result is returned.
// This can be checked by the empty field of the TResult
//
// @return the result
//
// Parameters:
//  - Table: the table to get from
//  - Tget: the TGet to fetch
func (p *THBaseServiceClient) Get(table []byte, tget *TGet) (r *TResult_, err error) {
	if err = p.sendGet(table, tget); err != nil {
		return
	}
	return p.recvGet()
}

func (p *THBaseServiceClient) sendGet(table []byte, tget *TGet) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("get", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := THBaseServiceGetArgs{
		Table: table,
		Tget:  tget,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvGet() (value *TResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "get" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "get failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "get failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error36 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error37 error
		error37, err = error36.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error37
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "get failed: invalid message type")
		return
	}
	result := THBaseServiceGetResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Method for getting multiple rows.
//
// If a row cannot be found there will be a null
// value in the result list for that TGet at the
// same position.
//
// So the Results are in the same order as the TGets.
//
// Parameters:
//  - Table: the table to get from
//  - Tgets: a list of TGets to fetch, the Result list
// will have the Results at corresponding positions
// or null if there was an error
func (p *THBaseServiceClient) GetMultiple(table []byte, tgets []*TGet) (r []*TResult_, err error) {
	if err = p.sendGetMultiple(table, tgets); err != nil {
		return
	}
	return p.recvGetMultiple()
}

func (p *THBaseServiceClient) sendGetMultiple(table []byte, tgets []*TGet) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getMultiple", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := THBaseServiceGetMultipleArgs{
		Table: table,
		Tgets: tgets,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvGetMultiple() (value []*TResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "getMultiple" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "getMultiple failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getMultiple failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error38 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error39 error
		error39, err = error38.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error39
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "getMultiple failed: invalid message type")
		return
	}
	result := THBaseServiceGetMultipleResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Commit a TPut to a table.
//
// Parameters:
//  - Table: the table to put data in
//  - Tput: the TPut to put
func (p *THBaseServiceClient) Put(table []byte, tput *TPut) (err error) {
	if err = p.sendPut(table, tput); err != nil {
		return
	}
	return p.recvPut()
}

func (p *THBaseServiceClient) sendPut(table []byte, tput *TPut) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("put", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := THBaseServicePutArgs{
		Table: table,
		Tput:  tput,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvPut() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "put" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "put failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "put failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error40 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error41 error
		error41, err = error40.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error41
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "put failed: invalid message type")
		return
	}
	result := THBaseServicePutResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	return
}

// Atomically checks if a row/family/qualifier value matches the expected
// value. If it does, it adds the TPut.
//
// @return true if the new put was executed, false otherwise
//
// Parameters:
//  - Table: to check in and put to
//  - Row: row to check
//  - Family: column family to check
//  - Qualifier: column qualifier to check
//  - Value: the expected value, if not provided the
// check is for the non-existence of the
// column in question
//  - Tput: the TPut to put if the check succeeds
func (p *THBaseServiceClient) CheckAndPut(table []byte, row []byte, family []byte, qualifier []byte, value []byte, tput *TPut) (r bool, err error) {
	if err = p.sendCheckAndPut(table, row, family, qualifier, value, tput); err != nil {
		return
	}
	return p.recvCheckAndPut()
}

func (p *THBaseServiceClient) sendCheckAndPut(table []byte, row []byte, family []byte, qualifier []byte, value []byte, tput *TPut) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("checkAndPut", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := THBaseServiceCheckAndPutArgs{
		Table:     table,
		Row:       row,
		Family:    family,
		Qualifier: qualifier,
		Value:     value,
		Tput:      tput,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvCheckAndPut() (value bool, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "checkAndPut" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "checkAndPut failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "checkAndPut failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error42 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error43 error
		error43, err = error42.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error43
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "checkAndPut failed: invalid message type")
		return
	}
	result := THBaseServiceCheckAndPutResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Commit a List of Puts to the table.
//
// Parameters:
//  - Table: the table to put data in
//  - Tputs: a list of TPuts to commit
func (p *THBaseServiceClient) PutMultiple(table []byte, tputs []*TPut) (err error) {
	if err = p.sendPutMultiple(table, tputs); err != nil {
		return
	}
	return p.recvPutMultiple()
}

func (p *THBaseServiceClient) sendPutMultiple(table []byte, tputs []*TPut) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("putMultiple", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := THBaseServicePutMultipleArgs{
		Table: table,
		Tputs: tputs,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvPutMultiple() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "putMultiple" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "putMultiple failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "putMultiple failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error44 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error45 error
		error45, err = error44.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error45
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "putMultiple failed: invalid message type")
		return
	}
	result := THBaseServicePutMultipleResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	return
}

// Deletes as specified by the TDelete.
//
// Note: "delete" is a reserved keyword and cannot be used in Thrift
// thus the inconsistent naming scheme from the other functions.
//
// Parameters:
//  - Table: the table to delete from
//  - Tdelete: the TDelete to delete
func (p *THBaseServiceClient) DeleteSingle(table []byte, tdelete *TDelete) (err error) {
	if err = p.sendDeleteSingle(table, tdelete); err != nil {
		return
	}
	return p.recvDeleteSingle()
}

func (p *THBaseServiceClient) sendDeleteSingle(table []byte, tdelete *TDelete) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("deleteSingle", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := THBaseServiceDeleteSingleArgs{
		Table:   table,
		Tdelete: tdelete,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvDeleteSingle() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "deleteSingle" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "deleteSingle failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "deleteSingle failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error46 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error47 error
		error47, err = error46.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error47
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "deleteSingle failed: invalid message type")
		return
	}
	result := THBaseServiceDeleteSingleResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	return
}

// Bulk commit a List of TDeletes to the table.
//
// Throws a TIOError if any of the deletes fail.
//
// Always returns an empty list for backwards compatibility.
//
// Parameters:
//  - Table: the table to delete from
//  - Tdeletes: list of TDeletes to delete
func (p *THBaseServiceClient) DeleteMultiple(table []byte, tdeletes []*TDelete) (r []*TDelete, err error) {
	if err = p.sendDeleteMultiple(table, tdeletes); err != nil {
		return
	}
	return p.recvDeleteMultiple()
}

func (p *THBaseServiceClient) sendDeleteMultiple(table []byte, tdeletes []*TDelete) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("deleteMultiple", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := THBaseServiceDeleteMultipleArgs{
		Table:    table,
		Tdeletes: tdeletes,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvDeleteMultiple() (value []*TDelete, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "deleteMultiple" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "deleteMultiple failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "deleteMultiple failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error48 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error49 error
		error49, err = error48.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error49
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "deleteMultiple failed: invalid message type")
		return
	}
	result := THBaseServiceDeleteMultipleResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Atomically checks if a row/family/qualifier value matches the expected
// value. If it does, it adds the delete.
//
// @return true if the new delete was executed, false otherwise
//
// Parameters:
//  - Table: to check in and delete from
//  - Row: row to check
//  - Family: column family to check
//  - Qualifier: column qualifier to check
//  - Value: the expected value, if not provided the
// check is for the non-existence of the
// column in question
//  - Tdelete: the TDelete to execute if the check succeeds
func (p *THBaseServiceClient) CheckAndDelete(table []byte, row []byte, family []byte, qualifier []byte, value []byte, tdelete *TDelete) (r bool, err error) {
	if err = p.sendCheckAndDelete(table, row, family, qualifier, value, tdelete); err != nil {
		return
	}
	return p.recvCheckAndDelete()
}

func (p *THBaseServiceClient) sendCheckAndDelete(table []byte, row []byte, family []byte, qualifier []byte, value []byte, tdelete *TDelete) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("checkAndDelete", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := THBaseServiceCheckAndDeleteArgs{
		Table:     table,
		Row:       row,
		Family:    family,
		Qualifier: qualifier,
		Value:     value,
		Tdelete:   tdelete,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvCheckAndDelete() (value bool, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "checkAndDelete" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "checkAndDelete failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "checkAndDelete failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error50 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error51 error
		error51, err = error50.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error51
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "checkAndDelete failed: invalid message type")
		return
	}
	result := THBaseServiceCheckAndDeleteResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - Table: the table to increment the value on
//  - Tincrement: the TIncrement to increment
func (p *THBaseServiceClient) Increment(table []byte, tincrement *TIncrement) (r *TResult_, err error) {
	if err = p.sendIncrement(table, tincrement); err != nil {
		return
	}
	return p.recvIncrement()
}

func (p *THBaseServiceClient) sendIncrement(table []byte, tincrement *TIncrement) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("increment", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := THBaseServiceIncrementArgs{
		Table:      table,
		Tincrement: tincrement,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvIncrement() (value *TResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "increment" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "increment failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "increment failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error52 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error53 error
		error53, err = error52.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error53
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "increment failed: invalid message type")
		return
	}
	result := THBaseServiceIncrementResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - Table: the table to append the value on
//  - Tappend: the TAppend to append
func (p *THBaseServiceClient) Append(table []byte, tappend *TAppend) (r *TResult_, err error) {
	if err = p.sendAppend(table, tappend); err != nil {
		return
	}
	return p.recvAppend()
}

func (p *THBaseServiceClient) sendAppend(table []byte, tappend *TAppend) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("append", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := THBaseServiceAppendArgs{
		Table:   table,
		Tappend: tappend,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvAppend() (value *TResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "append" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "append failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "append failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error54 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error55 error
		error55, err = error54.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error55
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "append failed: invalid message type")
		return
	}
	result := THBaseServiceAppendResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Get a Scanner for the provided TScan object.
//
// @return Scanner Id to be used with other scanner procedures
//
// Parameters:
//  - Table: the table to get the Scanner for
//  - Tscan: the scan object to get a Scanner for
func (p *THBaseServiceClient) OpenScanner(table []byte, tscan *TScan) (r int32, err error) {
	if err = p.sendOpenScanner(table, tscan); err != nil {
		return
	}
	return p.recvOpenScanner()
}

func (p *THBaseServiceClient) sendOpenScanner(table []byte, tscan *TScan) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("openScanner", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := THBaseServiceOpenScannerArgs{
		Table: table,
		Tscan: tscan,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvOpenScanner() (value int32, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "openScanner" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "openScanner failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "openScanner failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error56 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error57 error
		error57, err = error56.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error57
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "openScanner failed: invalid message type")
		return
	}
	result := THBaseServiceOpenScannerResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Grabs multiple rows from a Scanner.
//
// @return Between zero and numRows TResults
//
// Parameters:
//  - ScannerId: the Id of the Scanner to return rows from. This is an Id returned from the openScanner function.
//  - NumRows: number of rows to return
func (p *THBaseServiceClient) GetScannerRows(scannerId int32, numRows int32) (r []*TResult_, err error) {
	if err = p.sendGetScannerRows(scannerId, numRows); err != nil {
		return
	}
	return p.recvGetScannerRows()
}

func (p *THBaseServiceClient) sendGetScannerRows(scannerId int32, numRows int32) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getScannerRows", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := THBaseServiceGetScannerRowsArgs{
		ScannerId: scannerId,
		NumRows:   numRows,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvGetScannerRows() (value []*TResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "getScannerRows" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "getScannerRows failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getScannerRows failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error58 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error59 error
		error59, err = error58.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error59
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "getScannerRows failed: invalid message type")
		return
	}
	result := THBaseServiceGetScannerRowsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	} else if result.Ia != nil {
		err = result.Ia
		return
	}
	value = result.GetSuccess()
	return
}

// Closes the scanner. Should be called to free server side resources timely.
// Typically close once the scanner is not needed anymore, i.e. after looping
// over it to get all the required rows.
//
// Parameters:
//  - ScannerId: the Id of the Scanner to close *
func (p *THBaseServiceClient) CloseScanner(scannerId int32) (err error) {
	if err = p.sendCloseScanner(scannerId); err != nil {
		return
	}
	return p.recvCloseScanner()
}

func (p *THBaseServiceClient) sendCloseScanner(scannerId int32) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("closeScanner", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := THBaseServiceCloseScannerArgs{
		ScannerId: scannerId,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvCloseScanner() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "closeScanner" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "closeScanner failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "closeScanner failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error60 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error61 error
		error61, err = error60.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error61
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "closeScanner failed: invalid message type")
		return
	}
	result := THBaseServiceCloseScannerResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	} else if result.Ia != nil {
		err = result.Ia
		return
	}
	return
}

// mutateRow performs multiple mutations atomically on a single row.
//
// Parameters:
//  - Table: table to apply the mutations
//  - TrowMutations: mutations to apply
func (p *THBaseServiceClient) MutateRow(table []byte, trowMutations *TRowMutations) (err error) {
	if err = p.sendMutateRow(table, trowMutations); err != nil {
		return
	}
	return p.recvMutateRow()
}

func (p *THBaseServiceClient) sendMutateRow(table []byte, trowMutations *TRowMutations) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("mutateRow", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := THBaseServiceMutateRowArgs{
		Table:         table,
		TrowMutations: trowMutations,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvMutateRow() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "mutateRow" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "mutateRow failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "mutateRow failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error62 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error63 error
		error63, err = error62.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error63
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "mutateRow failed: invalid message type")
		return
	}
	result := THBaseServiceMutateRowResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	return
}

// Get results for the provided TScan object.
// This helper function opens a scanner, get the results and close the scanner.
//
// @return between zero and numRows TResults
//
// Parameters:
//  - Table: the table to get the Scanner for
//  - Tscan: the scan object to get a Scanner for
//  - NumRows: number of rows to return
func (p *THBaseServiceClient) GetScannerResults(table []byte, tscan *TScan, numRows int32) (r []*TResult_, err error) {
	if err = p.sendGetScannerResults(table, tscan, numRows); err != nil {
		return
	}
	return p.recvGetScannerResults()
}

func (p *THBaseServiceClient) sendGetScannerResults(table []byte, tscan *TScan, numRows int32) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getScannerResults", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := THBaseServiceGetScannerResultsArgs{
		Table:   table,
		Tscan:   tscan,
		NumRows: numRows,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvGetScannerResults() (value []*TResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "getScannerResults" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "getScannerResults failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getScannerResults failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error64 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error65 error
		error65, err = error64.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error65
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "getScannerResults failed: invalid message type")
		return
	}
	result := THBaseServiceGetScannerResultsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Given a table and a row get the location of the region that
// would contain the given row key.
//
// reload = true means the cache will be cleared and the location
// will be fetched from meta.
//
// Parameters:
//  - Table
//  - Row
//  - Reload
func (p *THBaseServiceClient) GetRegionLocation(table []byte, row []byte, reload bool) (r *THRegionLocation, err error) {
	if err = p.sendGetRegionLocation(table, row, reload); err != nil {
		return
	}
	return p.recvGetRegionLocation()
}

func (p *THBaseServiceClient) sendGetRegionLocation(table []byte, row []byte, reload bool) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getRegionLocation", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := THBaseServiceGetRegionLocationArgs{
		Table:  table,
		Row:    row,
		Reload: reload,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvGetRegionLocation() (value *THRegionLocation, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "getRegionLocation" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "getRegionLocation failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getRegionLocation failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error66 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error67 error
		error67, err = error66.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error67
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "getRegionLocation failed: invalid message type")
		return
	}
	result := THBaseServiceGetRegionLocationResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Get all of the region locations for a given table.
//
//
// Parameters:
//  - Table
func (p *THBaseServiceClient) GetAllRegionLocations(table []byte) (r []*THRegionLocation, err error) {
	if err = p.sendGetAllRegionLocations(table); err != nil {
		return
	}
	return p.recvGetAllRegionLocations()
}

func (p *THBaseServiceClient) sendGetAllRegionLocations(table []byte) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getAllRegionLocations", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := THBaseServiceGetAllRegionLocationsArgs{
		Table: table,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvGetAllRegionLocations() (value []*THRegionLocation, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "getAllRegionLocations" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "getAllRegionLocations failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getAllRegionLocations failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error68 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error69 error
		error69, err = error68.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error69
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "getAllRegionLocations failed: invalid message type")
		return
	}
	result := THBaseServiceGetAllRegionLocationsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Atomically checks if a row/family/qualifier value matches the expected
// value. If it does, it mutates the row.
//
// @return true if the row was mutated, false otherwise
//
// Parameters:
//  - Table: to check in and delete from
//  - Row: row to check
//  - Family: column family to check
//  - Qualifier: column qualifier to check
//  - CompareOp: comparison to make on the value
//  - Value: the expected value to be compared against, if not provided the
// check is for the non-existence of the column in question
//  - RowMutations: row mutations to execute if the value matches
func (p *THBaseServiceClient) CheckAndMutate(table []byte, row []byte, family []byte, qualifier []byte, compareOp TCompareOp, value []byte, rowMutations *TRowMutations) (r bool, err error) {
	if err = p.sendCheckAndMutate(table, row, family, qualifier, compareOp, value, rowMutations); err != nil {
		return
	}
	return p.recvCheckAndMutate()
}

func (p *THBaseServiceClient) sendCheckAndMutate(table []byte, row []byte, family []byte, qualifier []byte, compareOp TCompareOp, value []byte, rowMutations *TRowMutations) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("checkAndMutate", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := THBaseServiceCheckAndMutateArgs{
		Table:        table,
		Row:          row,
		Family:       family,
		Qualifier:    qualifier,
		CompareOp:    compareOp,
		Value:        value,
		RowMutations: rowMutations,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvCheckAndMutate() (value bool, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "checkAndMutate" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "checkAndMutate failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "checkAndMutate failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error70 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error71 error
		error71, err = error70.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error71
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "checkAndMutate failed: invalid message type")
		return
	}
	result := THBaseServiceCheckAndMutateResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Get a table descriptor.
// @return the TableDescriptor of the giving tablename
//
//
// Parameters:
//  - Table: the tablename of the table to get tableDescriptor
func (p *THBaseServiceClient) GetTableDescriptor(table *TTableName) (r *TTableDescriptor, err error) {
	if err = p.sendGetTableDescriptor(table); err != nil {
		return
	}
	return p.recvGetTableDescriptor()
}

func (p *THBaseServiceClient) sendGetTableDescriptor(table *TTableName) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getTableDescriptor", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := THBaseServiceGetTableDescriptorArgs{
		Table: table,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvGetTableDescriptor() (value *TTableDescriptor, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "getTableDescriptor" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "getTableDescriptor failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getTableDescriptor failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error72 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error73 error
		error73, err = error72.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error73
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "getTableDescriptor failed: invalid message type")
		return
	}
	result := THBaseServiceGetTableDescriptorResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Get table descriptors of tables.
// @return the TableDescriptor of the giving tablename
//
//
// Parameters:
//  - Tables: the tablename list of the tables to get tableDescriptor
func (p *THBaseServiceClient) GetTableDescriptors(tables []*TTableName) (r []*TTableDescriptor, err error) {
	if err = p.sendGetTableDescriptors(tables); err != nil {
		return
	}
	return p.recvGetTableDescriptors()
}

func (p *THBaseServiceClient) sendGetTableDescriptors(tables []*TTableName) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getTableDescriptors", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := THBaseServiceGetTableDescriptorsArgs{
		Tables: tables,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvGetTableDescriptors() (value []*TTableDescriptor, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "getTableDescriptors" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "getTableDescriptors failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getTableDescriptors failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error74 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error75 error
		error75, err = error74.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error75
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "getTableDescriptors failed: invalid message type")
		return
	}
	result := THBaseServiceGetTableDescriptorsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

//
// @return true if table exists already, false if not
//
//
// Parameters:
//  - TableName: the tablename of the tables to check
func (p *THBaseServiceClient) TableExists(tableName *TTableName) (r bool, err error) {
	if err = p.sendTableExists(tableName); err != nil {
		return
	}
	return p.recvTableExists()
}

func (p *THBaseServiceClient) sendTableExists(tableName *TTableName) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("tableExists", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := THBaseServiceTableExistsArgs{
		TableName: tableName,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvTableExists() (value bool, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "tableExists" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "tableExists failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "tableExists failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error76 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error77 error
		error77, err = error76.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error77
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "tableExists failed: invalid message type")
		return
	}
	result := THBaseServiceTableExistsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Get table descriptors of tables that match the given pattern
// @return the tableDescriptors of the matching table
//
//
// Parameters:
//  - Regex: The regular expression to match against
//  - IncludeSysTables: set to false if match only against userspace tables
func (p *THBaseServiceClient) GetTableDescriptorsByPattern(regex string, includeSysTables bool) (r []*TTableDescriptor, err error) {
	if err = p.sendGetTableDescriptorsByPattern(regex, includeSysTables); err != nil {
		return
	}
	return p.recvGetTableDescriptorsByPattern()
}

func (p *THBaseServiceClient) sendGetTableDescriptorsByPattern(regex string, includeSysTables bool) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getTableDescriptorsByPattern", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := THBaseServiceGetTableDescriptorsByPatternArgs{
		Regex:            regex,
		IncludeSysTables: includeSysTables,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvGetTableDescriptorsByPattern() (value []*TTableDescriptor, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "getTableDescriptorsByPattern" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "getTableDescriptorsByPattern failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getTableDescriptorsByPattern failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error78 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error79 error
		error79, err = error78.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error79
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "getTableDescriptorsByPattern failed: invalid message type")
		return
	}
	result := THBaseServiceGetTableDescriptorsByPatternResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Get table descriptors of tables in the given namespace
// @return the tableDescriptors in the namespce
//
//
// Parameters:
//  - Name: The namesapce's name
func (p *THBaseServiceClient) GetTableDescriptorsByNamespace(name string) (r []*TTableDescriptor, err error) {
	if err = p.sendGetTableDescriptorsByNamespace(name); err != nil {
		return
	}
	return p.recvGetTableDescriptorsByNamespace()
}

func (p *THBaseServiceClient) sendGetTableDescriptorsByNamespace(name string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getTableDescriptorsByNamespace", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := THBaseServiceGetTableDescriptorsByNamespaceArgs{
		Name: name,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvGetTableDescriptorsByNamespace() (value []*TTableDescriptor, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "getTableDescriptorsByNamespace" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "getTableDescriptorsByNamespace failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getTableDescriptorsByNamespace failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error80 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error81 error
		error81, err = error80.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error81
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "getTableDescriptorsByNamespace failed: invalid message type")
		return
	}
	result := THBaseServiceGetTableDescriptorsByNamespaceResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Get table names of tables that match the given pattern
// @return the table names of the matching table
//
//
// Parameters:
//  - Regex: The regular expression to match against
//  - IncludeSysTables: set to false if match only against userspace tables
func (p *THBaseServiceClient) GetTableNamesByPattern(regex string, includeSysTables bool) (r []*TTableName, err error) {
	if err = p.sendGetTableNamesByPattern(regex, includeSysTables); err != nil {
		return
	}
	return p.recvGetTableNamesByPattern()
}

func (p *THBaseServiceClient) sendGetTableNamesByPattern(regex string, includeSysTables bool) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getTableNamesByPattern", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := THBaseServiceGetTableNamesByPatternArgs{
		Regex:            regex,
		IncludeSysTables: includeSysTables,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvGetTableNamesByPattern() (value []*TTableName, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "getTableNamesByPattern" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "getTableNamesByPattern failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getTableNamesByPattern failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error82 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error83 error
		error83, err = error82.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error83
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "getTableNamesByPattern failed: invalid message type")
		return
	}
	result := THBaseServiceGetTableNamesByPatternResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Get table names of tables in the given namespace
// @return the table names of the matching table
//
//
// Parameters:
//  - Name: The namesapce's name
func (p *THBaseServiceClient) GetTableNamesByNamespace(name string) (r []*TTableName, err error) {
	if err = p.sendGetTableNamesByNamespace(name); err != nil {
		return
	}
	return p.recvGetTableNamesByNamespace()
}

func (p *THBaseServiceClient) sendGetTableNamesByNamespace(name string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getTableNamesByNamespace", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := THBaseServiceGetTableNamesByNamespaceArgs{
		Name: name,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvGetTableNamesByNamespace() (value []*TTableName, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "getTableNamesByNamespace" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "getTableNamesByNamespace failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getTableNamesByNamespace failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error84 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error85 error
		error85, err = error84.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error85
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "getTableNamesByNamespace failed: invalid message type")
		return
	}
	result := THBaseServiceGetTableNamesByNamespaceResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Creates a new table with an initial set of empty regions defined by the specified split keys.
// The total number of regions created will be the number of split keys plus one. Synchronous
// operation.
//
//
// Parameters:
//  - Desc: table descriptor for table
//  - SplitKeys: rray of split keys for the initial regions of the table
func (p *THBaseServiceClient) CreateTable(desc *TTableDescriptor, splitKeys [][]byte) (err error) {
	if err = p.sendCreateTable(desc, splitKeys); err != nil {
		return
	}
	return p.recvCreateTable()
}

func (p *THBaseServiceClient) sendCreateTable(desc *TTableDescriptor, splitKeys [][]byte) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("createTable", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := THBaseServiceCreateTableArgs{
		Desc:      desc,
		SplitKeys: splitKeys,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvCreateTable() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "createTable" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "createTable failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "createTable failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error86 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error87 error
		error87, err = error86.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error87
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "createTable failed: invalid message type")
		return
	}
	result := THBaseServiceCreateTableResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	return
}

// Deletes a table. Synchronous operation.
//
//
// Parameters:
//  - TableName: the tablename to delete
func (p *THBaseServiceClient) DeleteTable(tableName *TTableName) (err error) {
	if err = p.sendDeleteTable(tableName); err != nil {
		return
	}
	return p.recvDeleteTable()
}

func (p *THBaseServiceClient) sendDeleteTable(tableName *TTableName) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("deleteTable", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := THBaseServiceDeleteTableArgs{
		TableName: tableName,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvDeleteTable() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "deleteTable" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "deleteTable failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "deleteTable failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error88 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error89 error
		error89, err = error88.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error89
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "deleteTable failed: invalid message type")
		return
	}
	result := THBaseServiceDeleteTableResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	return
}

// Truncate a table. Synchronous operation.
//
//
// Parameters:
//  - TableName: the tablename to truncate
//  - PreserveSplits: whether to  preserve previous splits
func (p *THBaseServiceClient) TruncateTable(tableName *TTableName, preserveSplits bool) (err error) {
	if err = p.sendTruncateTable(tableName, preserveSplits); err != nil {
		return
	}
	return p.recvTruncateTable()
}

func (p *THBaseServiceClient) sendTruncateTable(tableName *TTableName, preserveSplits bool) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("truncateTable", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := THBaseServiceTruncateTableArgs{
		TableName:      tableName,
		PreserveSplits: preserveSplits,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvTruncateTable() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "truncateTable" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "truncateTable failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "truncateTable failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error90 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error91 error
		error91, err = error90.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error91
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "truncateTable failed: invalid message type")
		return
	}
	result := THBaseServiceTruncateTableResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	return
}

// Enalbe a table
//
//
// Parameters:
//  - TableName: the tablename to enable
func (p *THBaseServiceClient) EnableTable(tableName *TTableName) (err error) {
	if err = p.sendEnableTable(tableName); err != nil {
		return
	}
	return p.recvEnableTable()
}

func (p *THBaseServiceClient) sendEnableTable(tableName *TTableName) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("enableTable", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := THBaseServiceEnableTableArgs{
		TableName: tableName,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvEnableTable() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "enableTable" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "enableTable failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "enableTable failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error92 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error93 error
		error93, err = error92.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error93
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "enableTable failed: invalid message type")
		return
	}
	result := THBaseServiceEnableTableResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	return
}

// Disable a table
//
//
// Parameters:
//  - TableName: the tablename to disable
func (p *THBaseServiceClient) DisableTable(tableName *TTableName) (err error) {
	if err = p.sendDisableTable(tableName); err != nil {
		return
	}
	return p.recvDisableTable()
}

func (p *THBaseServiceClient) sendDisableTable(tableName *TTableName) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("disableTable", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := THBaseServiceDisableTableArgs{
		TableName: tableName,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvDisableTable() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "disableTable" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "disableTable failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "disableTable failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error94 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error95 error
		error95, err = error94.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error95
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "disableTable failed: invalid message type")
		return
	}
	result := THBaseServiceDisableTableResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	return
}

//
// @return true if table is enabled, false if not
//
//
// Parameters:
//  - TableName: the tablename to check
func (p *THBaseServiceClient) IsTableEnabled(tableName *TTableName) (r bool, err error) {
	if err = p.sendIsTableEnabled(tableName); err != nil {
		return
	}
	return p.recvIsTableEnabled()
}

func (p *THBaseServiceClient) sendIsTableEnabled(tableName *TTableName) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("isTableEnabled", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := THBaseServiceIsTableEnabledArgs{
		TableName: tableName,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvIsTableEnabled() (value bool, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "isTableEnabled" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "isTableEnabled failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "isTableEnabled failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error96 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error97 error
		error97, err = error96.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error97
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "isTableEnabled failed: invalid message type")
		return
	}
	result := THBaseServiceIsTableEnabledResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

//
// @return true if table is disabled, false if not
//
//
// Parameters:
//  - TableName: the tablename to check
func (p *THBaseServiceClient) IsTableDisabled(tableName *TTableName) (r bool, err error) {
	if err = p.sendIsTableDisabled(tableName); err != nil {
		return
	}
	return p.recvIsTableDisabled()
}

func (p *THBaseServiceClient) sendIsTableDisabled(tableName *TTableName) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("isTableDisabled", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := THBaseServiceIsTableDisabledArgs{
		TableName: tableName,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvIsTableDisabled() (value bool, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "isTableDisabled" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "isTableDisabled failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "isTableDisabled failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error98 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error99 error
		error99, err = error98.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error99
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "isTableDisabled failed: invalid message type")
		return
	}
	result := THBaseServiceIsTableDisabledResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

//
// @return true if table is available, false if not
//
//
// Parameters:
//  - TableName: the tablename to check
func (p *THBaseServiceClient) IsTableAvailable(tableName *TTableName) (r bool, err error) {
	if err = p.sendIsTableAvailable(tableName); err != nil {
		return
	}
	return p.recvIsTableAvailable()
}

func (p *THBaseServiceClient) sendIsTableAvailable(tableName *TTableName) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("isTableAvailable", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := THBaseServiceIsTableAvailableArgs{
		TableName: tableName,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvIsTableAvailable() (value bool, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "isTableAvailable" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "isTableAvailable failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "isTableAvailable failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error100 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error101 error
		error101, err = error100.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error101
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "isTableAvailable failed: invalid message type")
		return
	}
	result := THBaseServiceIsTableAvailableResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

//  * Use this api to check if the table has been created with the specified number of splitkeys
//  * which was used while creating the given table. Note : If this api is used after a table's
//  * region gets splitted, the api may return false.
//  *
//  * @return true if table is available, false if not
//  *
//  * @deprecated Since 2.2.0. Because the same method in Table interface has been deprecated
//  * since 2.0.0, we will remove it in 3.0.0 release.
//  * Use {@link #isTableAvailable(TTableName tableName)} instead
// *
//
// Parameters:
//  - TableName: the tablename to check
//  - SplitKeys: keys to check if the table has been created with all split keys
func (p *THBaseServiceClient) IsTableAvailableWithSplit(tableName *TTableName, splitKeys [][]byte) (r bool, err error) {
	if err = p.sendIsTableAvailableWithSplit(tableName, splitKeys); err != nil {
		return
	}
	return p.recvIsTableAvailableWithSplit()
}

func (p *THBaseServiceClient) sendIsTableAvailableWithSplit(tableName *TTableName, splitKeys [][]byte) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("isTableAvailableWithSplit", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := THBaseServiceIsTableAvailableWithSplitArgs{
		TableName: tableName,
		SplitKeys: splitKeys,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvIsTableAvailableWithSplit() (value bool, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "isTableAvailableWithSplit" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "isTableAvailableWithSplit failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "isTableAvailableWithSplit failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error102 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error103 error
		error103, err = error102.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error103
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "isTableAvailableWithSplit failed: invalid message type")
		return
	}
	result := THBaseServiceIsTableAvailableWithSplitResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Add a column family to an existing table. Synchronous operation.
//
//
// Parameters:
//  - TableName: the tablename to add column family to
//  - Column: column family descriptor of column family to be added
func (p *THBaseServiceClient) AddColumnFamily(tableName *TTableName, column *TColumnFamilyDescriptor) (err error) {
	if err = p.sendAddColumnFamily(tableName, column); err != nil {
		return
	}
	return p.recvAddColumnFamily()
}

func (p *THBaseServiceClient) sendAddColumnFamily(tableName *TTableName, column *TColumnFamilyDescriptor) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("addColumnFamily", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := THBaseServiceAddColumnFamilyArgs{
		TableName: tableName,
		Column:    column,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvAddColumnFamily() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "addColumnFamily" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "addColumnFamily failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "addColumnFamily failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error104 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error105 error
		error105, err = error104.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error105
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "addColumnFamily failed: invalid message type")
		return
	}
	result := THBaseServiceAddColumnFamilyResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	return
}

// Delete a column family from a table. Synchronous operation.
//
//
// Parameters:
//  - TableName: the tablename to delete column family from
//  - Column: name of column family to be deleted
func (p *THBaseServiceClient) DeleteColumnFamily(tableName *TTableName, column []byte) (err error) {
	if err = p.sendDeleteColumnFamily(tableName, column); err != nil {
		return
	}
	return p.recvDeleteColumnFamily()
}

func (p *THBaseServiceClient) sendDeleteColumnFamily(tableName *TTableName, column []byte) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("deleteColumnFamily", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := THBaseServiceDeleteColumnFamilyArgs{
		TableName: tableName,
		Column:    column,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvDeleteColumnFamily() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "deleteColumnFamily" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "deleteColumnFamily failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "deleteColumnFamily failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error106 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error107 error
		error107, err = error106.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error107
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "deleteColumnFamily failed: invalid message type")
		return
	}
	result := THBaseServiceDeleteColumnFamilyResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	return
}

// Modify an existing column family on a table. Synchronous operation.
//
//
// Parameters:
//  - TableName: the tablename to modify column family
//  - Column: column family descriptor of column family to be modified
func (p *THBaseServiceClient) ModifyColumnFamily(tableName *TTableName, column *TColumnFamilyDescriptor) (err error) {
	if err = p.sendModifyColumnFamily(tableName, column); err != nil {
		return
	}
	return p.recvModifyColumnFamily()
}

func (p *THBaseServiceClient) sendModifyColumnFamily(tableName *TTableName, column *TColumnFamilyDescriptor) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("modifyColumnFamily", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := THBaseServiceModifyColumnFamilyArgs{
		TableName: tableName,
		Column:    column,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvModifyColumnFamily() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "modifyColumnFamily" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "modifyColumnFamily failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "modifyColumnFamily failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error108 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error109 error
		error109, err = error108.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error109
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "modifyColumnFamily failed: invalid message type")
		return
	}
	result := THBaseServiceModifyColumnFamilyResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	return
}

// Modify an existing table
//
//
// Parameters:
//  - Desc: the descriptor of the table to modify
func (p *THBaseServiceClient) ModifyTable(desc *TTableDescriptor) (err error) {
	if err = p.sendModifyTable(desc); err != nil {
		return
	}
	return p.recvModifyTable()
}

func (p *THBaseServiceClient) sendModifyTable(desc *TTableDescriptor) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("modifyTable", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := THBaseServiceModifyTableArgs{
		Desc: desc,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvModifyTable() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "modifyTable" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "modifyTable failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "modifyTable failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error110 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error111 error
		error111, err = error110.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error111
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "modifyTable failed: invalid message type")
		return
	}
	result := THBaseServiceModifyTableResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	return
}

// Create a new namespace. Blocks until namespace has been successfully created or an exception is
// thrown
//
//
// Parameters:
//  - NamespaceDesc: descriptor which describes the new namespace
func (p *THBaseServiceClient) CreateNamespace(namespaceDesc *TNamespaceDescriptor) (err error) {
	if err = p.sendCreateNamespace(namespaceDesc); err != nil {
		return
	}
	return p.recvCreateNamespace()
}

func (p *THBaseServiceClient) sendCreateNamespace(namespaceDesc *TNamespaceDescriptor) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("createNamespace", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := THBaseServiceCreateNamespaceArgs{
		NamespaceDesc: namespaceDesc,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvCreateNamespace() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "createNamespace" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "createNamespace failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "createNamespace failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error112 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error113 error
		error113, err = error112.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error113
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "createNamespace failed: invalid message type")
		return
	}
	result := THBaseServiceCreateNamespaceResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	return
}

// Modify an existing namespace.  Blocks until namespace has been successfully modified or an
// exception is thrown
//
//
// Parameters:
//  - NamespaceDesc: descriptor which describes the new namespace
func (p *THBaseServiceClient) ModifyNamespace(namespaceDesc *TNamespaceDescriptor) (err error) {
	if err = p.sendModifyNamespace(namespaceDesc); err != nil {
		return
	}
	return p.recvModifyNamespace()
}

func (p *THBaseServiceClient) sendModifyNamespace(namespaceDesc *TNamespaceDescriptor) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("modifyNamespace", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := THBaseServiceModifyNamespaceArgs{
		NamespaceDesc: namespaceDesc,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvModifyNamespace() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "modifyNamespace" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "modifyNamespace failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "modifyNamespace failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error114 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error115 error
		error115, err = error114.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error115
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "modifyNamespace failed: invalid message type")
		return
	}
	result := THBaseServiceModifyNamespaceResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	return
}

// Delete an existing namespace. Only empty namespaces (no tables) can be removed.
// Blocks until namespace has been successfully deleted or an
// exception is thrown.
//
//
// Parameters:
//  - Name: namespace name
func (p *THBaseServiceClient) DeleteNamespace(name string) (err error) {
	if err = p.sendDeleteNamespace(name); err != nil {
		return
	}
	return p.recvDeleteNamespace()
}

func (p *THBaseServiceClient) sendDeleteNamespace(name string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("deleteNamespace", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := THBaseServiceDeleteNamespaceArgs{
		Name: name,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvDeleteNamespace() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "deleteNamespace" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "deleteNamespace failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "deleteNamespace failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error116 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error117 error
		error117, err = error116.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error117
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "deleteNamespace failed: invalid message type")
		return
	}
	result := THBaseServiceDeleteNamespaceResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	return
}

// Get a namespace descriptor by name.
// @retrun the descriptor
//
//
// Parameters:
//  - Name: name of namespace descriptor
func (p *THBaseServiceClient) GetNamespaceDescriptor(name string) (r *TNamespaceDescriptor, err error) {
	if err = p.sendGetNamespaceDescriptor(name); err != nil {
		return
	}
	return p.recvGetNamespaceDescriptor()
}

func (p *THBaseServiceClient) sendGetNamespaceDescriptor(name string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getNamespaceDescriptor", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := THBaseServiceGetNamespaceDescriptorArgs{
		Name: name,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvGetNamespaceDescriptor() (value *TNamespaceDescriptor, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "getNamespaceDescriptor" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "getNamespaceDescriptor failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getNamespaceDescriptor failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error118 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error119 error
		error119, err = error118.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error119
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "getNamespaceDescriptor failed: invalid message type")
		return
	}
	result := THBaseServiceGetNamespaceDescriptorResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// @return all namespaces
//
func (p *THBaseServiceClient) ListNamespaceDescriptors() (r []*TNamespaceDescriptor, err error) {
	if err = p.sendListNamespaceDescriptors(); err != nil {
		return
	}
	return p.recvListNamespaceDescriptors()
}

func (p *THBaseServiceClient) sendListNamespaceDescriptors() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("listNamespaceDescriptors", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := THBaseServiceListNamespaceDescriptorsArgs{}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvListNamespaceDescriptors() (value []*TNamespaceDescriptor, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "listNamespaceDescriptors" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "listNamespaceDescriptors failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "listNamespaceDescriptors failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error120 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error121 error
		error121, err = error120.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error121
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "listNamespaceDescriptors failed: invalid message type")
		return
	}
	result := THBaseServiceListNamespaceDescriptorsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

type THBaseServiceProcessor struct {
	processorMap map[string]thrift.TProcessorFunction
	handler      THBaseService
}

func (p *THBaseServiceProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
	p.processorMap[key] = processor
}

func (p *THBaseServiceProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
	processor, ok = p.processorMap[key]
	return processor, ok
}

func (p *THBaseServiceProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
	return p.processorMap
}

func NewTHBaseServiceProcessor(handler THBaseService) *THBaseServiceProcessor {

	self122 := &THBaseServiceProcessor{handler: handler, processorMap: make(map[string]thrift.TProcessorFunction)}
	self122.processorMap["exists"] = &tHBaseServiceProcessorExists{handler: handler}
	self122.processorMap["existsAll"] = &tHBaseServiceProcessorExistsAll{handler: handler}
	self122.processorMap["get"] = &tHBaseServiceProcessorGet{handler: handler}
	self122.processorMap["getMultiple"] = &tHBaseServiceProcessorGetMultiple{handler: handler}
	self122.processorMap["put"] = &tHBaseServiceProcessorPut{handler: handler}
	self122.processorMap["checkAndPut"] = &tHBaseServiceProcessorCheckAndPut{handler: handler}
	self122.processorMap["putMultiple"] = &tHBaseServiceProcessorPutMultiple{handler: handler}
	self122.processorMap["deleteSingle"] = &tHBaseServiceProcessorDeleteSingle{handler: handler}
	self122.processorMap["deleteMultiple"] = &tHBaseServiceProcessorDeleteMultiple{handler: handler}
	self122.processorMap["checkAndDelete"] = &tHBaseServiceProcessorCheckAndDelete{handler: handler}
	self122.processorMap["increment"] = &tHBaseServiceProcessorIncrement{handler: handler}
	self122.processorMap["append"] = &tHBaseServiceProcessorAppend{handler: handler}
	self122.processorMap["openScanner"] = &tHBaseServiceProcessorOpenScanner{handler: handler}
	self122.processorMap["getScannerRows"] = &tHBaseServiceProcessorGetScannerRows{handler: handler}
	self122.processorMap["closeScanner"] = &tHBaseServiceProcessorCloseScanner{handler: handler}
	self122.processorMap["mutateRow"] = &tHBaseServiceProcessorMutateRow{handler: handler}
	self122.processorMap["getScannerResults"] = &tHBaseServiceProcessorGetScannerResults{handler: handler}
	self122.processorMap["getRegionLocation"] = &tHBaseServiceProcessorGetRegionLocation{handler: handler}
	self122.processorMap["getAllRegionLocations"] = &tHBaseServiceProcessorGetAllRegionLocations{handler: handler}
	self122.processorMap["checkAndMutate"] = &tHBaseServiceProcessorCheckAndMutate{handler: handler}
	self122.processorMap["getTableDescriptor"] = &tHBaseServiceProcessorGetTableDescriptor{handler: handler}
	self122.processorMap["getTableDescriptors"] = &tHBaseServiceProcessorGetTableDescriptors{handler: handler}
	self122.processorMap["tableExists"] = &tHBaseServiceProcessorTableExists{handler: handler}
	self122.processorMap["getTableDescriptorsByPattern"] = &tHBaseServiceProcessorGetTableDescriptorsByPattern{handler: handler}
	self122.processorMap["getTableDescriptorsByNamespace"] = &tHBaseServiceProcessorGetTableDescriptorsByNamespace{handler: handler}
	self122.processorMap["getTableNamesByPattern"] = &tHBaseServiceProcessorGetTableNamesByPattern{handler: handler}
	self122.processorMap["getTableNamesByNamespace"] = &tHBaseServiceProcessorGetTableNamesByNamespace{handler: handler}
	self122.processorMap["createTable"] = &tHBaseServiceProcessorCreateTable{handler: handler}
	self122.processorMap["deleteTable"] = &tHBaseServiceProcessorDeleteTable{handler: handler}
	self122.processorMap["truncateTable"] = &tHBaseServiceProcessorTruncateTable{handler: handler}
	self122.processorMap["enableTable"] = &tHBaseServiceProcessorEnableTable{handler: handler}
	self122.processorMap["disableTable"] = &tHBaseServiceProcessorDisableTable{handler: handler}
	self122.processorMap["isTableEnabled"] = &tHBaseServiceProcessorIsTableEnabled{handler: handler}
	self122.processorMap["isTableDisabled"] = &tHBaseServiceProcessorIsTableDisabled{handler: handler}
	self122.processorMap["isTableAvailable"] = &tHBaseServiceProcessorIsTableAvailable{handler: handler}
	self122.processorMap["isTableAvailableWithSplit"] = &tHBaseServiceProcessorIsTableAvailableWithSplit{handler: handler}
	self122.processorMap["addColumnFamily"] = &tHBaseServiceProcessorAddColumnFamily{handler: handler}
	self122.processorMap["deleteColumnFamily"] = &tHBaseServiceProcessorDeleteColumnFamily{handler: handler}
	self122.processorMap["modifyColumnFamily"] = &tHBaseServiceProcessorModifyColumnFamily{handler: handler}
	self122.processorMap["modifyTable"] = &tHBaseServiceProcessorModifyTable{handler: handler}
	self122.processorMap["createNamespace"] = &tHBaseServiceProcessorCreateNamespace{handler: handler}
	self122.processorMap["modifyNamespace"] = &tHBaseServiceProcessorModifyNamespace{handler: handler}
	self122.processorMap["deleteNamespace"] = &tHBaseServiceProcessorDeleteNamespace{handler: handler}
	self122.processorMap["getNamespaceDescriptor"] = &tHBaseServiceProcessorGetNamespaceDescriptor{handler: handler}
	self122.processorMap["listNamespaceDescriptors"] = &tHBaseServiceProcessorListNamespaceDescriptors{handler: handler}
	return self122
}

func (p *THBaseServiceProcessor) Process(iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	name, _, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return false, err
	}
	if processor, ok := p.GetProcessorFunction(name); ok {
		return processor.Process(seqId, iprot, oprot)
	}
	iprot.Skip(thrift.STRUCT)
	iprot.ReadMessageEnd()
	x123 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function "+name)
	oprot.WriteMessageBegin(name, thrift.EXCEPTION, seqId)
	x123.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return false, x123

}

type tHBaseServiceProcessorExists struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorExists) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := THBaseServiceExistsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("exists", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := THBaseServiceExistsResult{}
	var retval bool
	var err2 error
	if retval, err2 = p.handler.Exists(args.Table, args.Tget); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing exists: "+err2.Error())
			oprot.WriteMessageBegin("exists", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("exists", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorExistsAll struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorExistsAll) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := THBaseServiceExistsAllArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("existsAll", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := THBaseServiceExistsAllResult{}
	var retval []bool
	var err2 error
	if retval, err2 = p.handler.ExistsAll(args.Table, args.Tgets); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing existsAll: "+err2.Error())
			oprot.WriteMessageBegin("existsAll", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("existsAll", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorGet struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorGet) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := THBaseServiceGetArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("get", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := THBaseServiceGetResult{}
	var retval *TResult_
	var err2 error
	if retval, err2 = p.handler.Get(args.Table, args.Tget); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get: "+err2.Error())
			oprot.WriteMessageBegin("get", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("get", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorGetMultiple struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorGetMultiple) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := THBaseServiceGetMultipleArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getMultiple", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := THBaseServiceGetMultipleResult{}
	var retval []*TResult_
	var err2 error
	if retval, err2 = p.handler.GetMultiple(args.Table, args.Tgets); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getMultiple: "+err2.Error())
			oprot.WriteMessageBegin("getMultiple", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getMultiple", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorPut struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorPut) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := THBaseServicePutArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("put", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := THBaseServicePutResult{}
	var err2 error
	if err2 = p.handler.Put(args.Table, args.Tput); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing put: "+err2.Error())
			oprot.WriteMessageBegin("put", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("put", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorCheckAndPut struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorCheckAndPut) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := THBaseServiceCheckAndPutArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("checkAndPut", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := THBaseServiceCheckAndPutResult{}
	var retval bool
	var err2 error
	if retval, err2 = p.handler.CheckAndPut(args.Table, args.Row, args.Family, args.Qualifier, args.Value, args.Tput); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing checkAndPut: "+err2.Error())
			oprot.WriteMessageBegin("checkAndPut", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("checkAndPut", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorPutMultiple struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorPutMultiple) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := THBaseServicePutMultipleArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("putMultiple", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := THBaseServicePutMultipleResult{}
	var err2 error
	if err2 = p.handler.PutMultiple(args.Table, args.Tputs); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing putMultiple: "+err2.Error())
			oprot.WriteMessageBegin("putMultiple", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("putMultiple", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorDeleteSingle struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorDeleteSingle) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := THBaseServiceDeleteSingleArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("deleteSingle", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := THBaseServiceDeleteSingleResult{}
	var err2 error
	if err2 = p.handler.DeleteSingle(args.Table, args.Tdelete); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing deleteSingle: "+err2.Error())
			oprot.WriteMessageBegin("deleteSingle", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("deleteSingle", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorDeleteMultiple struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorDeleteMultiple) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := THBaseServiceDeleteMultipleArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("deleteMultiple", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := THBaseServiceDeleteMultipleResult{}
	var retval []*TDelete
	var err2 error
	if retval, err2 = p.handler.DeleteMultiple(args.Table, args.Tdeletes); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing deleteMultiple: "+err2.Error())
			oprot.WriteMessageBegin("deleteMultiple", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("deleteMultiple", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorCheckAndDelete struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorCheckAndDelete) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := THBaseServiceCheckAndDeleteArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("checkAndDelete", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := THBaseServiceCheckAndDeleteResult{}
	var retval bool
	var err2 error
	if retval, err2 = p.handler.CheckAndDelete(args.Table, args.Row, args.Family, args.Qualifier, args.Value, args.Tdelete); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing checkAndDelete: "+err2.Error())
			oprot.WriteMessageBegin("checkAndDelete", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("checkAndDelete", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorIncrement struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorIncrement) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := THBaseServiceIncrementArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("increment", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := THBaseServiceIncrementResult{}
	var retval *TResult_
	var err2 error
	if retval, err2 = p.handler.Increment(args.Table, args.Tincrement); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing increment: "+err2.Error())
			oprot.WriteMessageBegin("increment", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("increment", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorAppend struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorAppend) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := THBaseServiceAppendArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("append", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := THBaseServiceAppendResult{}
	var retval *TResult_
	var err2 error
	if retval, err2 = p.handler.Append(args.Table, args.Tappend); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing append: "+err2.Error())
			oprot.WriteMessageBegin("append", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("append", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorOpenScanner struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorOpenScanner) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := THBaseServiceOpenScannerArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("openScanner", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := THBaseServiceOpenScannerResult{}
	var retval int32
	var err2 error
	if retval, err2 = p.handler.OpenScanner(args.Table, args.Tscan); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing openScanner: "+err2.Error())
			oprot.WriteMessageBegin("openScanner", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("openScanner", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorGetScannerRows struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorGetScannerRows) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := THBaseServiceGetScannerRowsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getScannerRows", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := THBaseServiceGetScannerRowsResult{}
	var retval []*TResult_
	var err2 error
	if retval, err2 = p.handler.GetScannerRows(args.ScannerId, args.NumRows); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		case *TIllegalArgument:
			result.Ia = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getScannerRows: "+err2.Error())
			oprot.WriteMessageBegin("getScannerRows", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getScannerRows", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorCloseScanner struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorCloseScanner) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := THBaseServiceCloseScannerArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("closeScanner", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := THBaseServiceCloseScannerResult{}
	var err2 error
	if err2 = p.handler.CloseScanner(args.ScannerId); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		case *TIllegalArgument:
			result.Ia = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing closeScanner: "+err2.Error())
			oprot.WriteMessageBegin("closeScanner", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("closeScanner", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorMutateRow struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorMutateRow) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := THBaseServiceMutateRowArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("mutateRow", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := THBaseServiceMutateRowResult{}
	var err2 error
	if err2 = p.handler.MutateRow(args.Table, args.TrowMutations); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing mutateRow: "+err2.Error())
			oprot.WriteMessageBegin("mutateRow", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("mutateRow", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorGetScannerResults struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorGetScannerResults) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := THBaseServiceGetScannerResultsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getScannerResults", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := THBaseServiceGetScannerResultsResult{}
	var retval []*TResult_
	var err2 error
	if retval, err2 = p.handler.GetScannerResults(args.Table, args.Tscan, args.NumRows); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getScannerResults: "+err2.Error())
			oprot.WriteMessageBegin("getScannerResults", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getScannerResults", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorGetRegionLocation struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorGetRegionLocation) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := THBaseServiceGetRegionLocationArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getRegionLocation", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := THBaseServiceGetRegionLocationResult{}
	var retval *THRegionLocation
	var err2 error
	if retval, err2 = p.handler.GetRegionLocation(args.Table, args.Row, args.Reload); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getRegionLocation: "+err2.Error())
			oprot.WriteMessageBegin("getRegionLocation", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getRegionLocation", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorGetAllRegionLocations struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorGetAllRegionLocations) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := THBaseServiceGetAllRegionLocationsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getAllRegionLocations", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := THBaseServiceGetAllRegionLocationsResult{}
	var retval []*THRegionLocation
	var err2 error
	if retval, err2 = p.handler.GetAllRegionLocations(args.Table); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getAllRegionLocations: "+err2.Error())
			oprot.WriteMessageBegin("getAllRegionLocations", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getAllRegionLocations", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorCheckAndMutate struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorCheckAndMutate) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := THBaseServiceCheckAndMutateArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("checkAndMutate", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := THBaseServiceCheckAndMutateResult{}
	var retval bool
	var err2 error
	if retval, err2 = p.handler.CheckAndMutate(args.Table, args.Row, args.Family, args.Qualifier, args.CompareOp, args.Value, args.RowMutations); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing checkAndMutate: "+err2.Error())
			oprot.WriteMessageBegin("checkAndMutate", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("checkAndMutate", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorGetTableDescriptor struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorGetTableDescriptor) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := THBaseServiceGetTableDescriptorArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getTableDescriptor", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := THBaseServiceGetTableDescriptorResult{}
	var retval *TTableDescriptor
	var err2 error
	if retval, err2 = p.handler.GetTableDescriptor(args.Table); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getTableDescriptor: "+err2.Error())
			oprot.WriteMessageBegin("getTableDescriptor", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getTableDescriptor", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorGetTableDescriptors struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorGetTableDescriptors) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := THBaseServiceGetTableDescriptorsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getTableDescriptors", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := THBaseServiceGetTableDescriptorsResult{}
	var retval []*TTableDescriptor
	var err2 error
	if retval, err2 = p.handler.GetTableDescriptors(args.Tables); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getTableDescriptors: "+err2.Error())
			oprot.WriteMessageBegin("getTableDescriptors", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getTableDescriptors", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorTableExists struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorTableExists) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := THBaseServiceTableExistsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("tableExists", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := THBaseServiceTableExistsResult{}
	var retval bool
	var err2 error
	if retval, err2 = p.handler.TableExists(args.TableName); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing tableExists: "+err2.Error())
			oprot.WriteMessageBegin("tableExists", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("tableExists", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorGetTableDescriptorsByPattern struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorGetTableDescriptorsByPattern) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := THBaseServiceGetTableDescriptorsByPatternArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getTableDescriptorsByPattern", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := THBaseServiceGetTableDescriptorsByPatternResult{}
	var retval []*TTableDescriptor
	var err2 error
	if retval, err2 = p.handler.GetTableDescriptorsByPattern(args.Regex, args.IncludeSysTables); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getTableDescriptorsByPattern: "+err2.Error())
			oprot.WriteMessageBegin("getTableDescriptorsByPattern", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getTableDescriptorsByPattern", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorGetTableDescriptorsByNamespace struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorGetTableDescriptorsByNamespace) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := THBaseServiceGetTableDescriptorsByNamespaceArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getTableDescriptorsByNamespace", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := THBaseServiceGetTableDescriptorsByNamespaceResult{}
	var retval []*TTableDescriptor
	var err2 error
	if retval, err2 = p.handler.GetTableDescriptorsByNamespace(args.Name); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getTableDescriptorsByNamespace: "+err2.Error())
			oprot.WriteMessageBegin("getTableDescriptorsByNamespace", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getTableDescriptorsByNamespace", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorGetTableNamesByPattern struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorGetTableNamesByPattern) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := THBaseServiceGetTableNamesByPatternArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getTableNamesByPattern", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := THBaseServiceGetTableNamesByPatternResult{}
	var retval []*TTableName
	var err2 error
	if retval, err2 = p.handler.GetTableNamesByPattern(args.Regex, args.IncludeSysTables); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getTableNamesByPattern: "+err2.Error())
			oprot.WriteMessageBegin("getTableNamesByPattern", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getTableNamesByPattern", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorGetTableNamesByNamespace struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorGetTableNamesByNamespace) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := THBaseServiceGetTableNamesByNamespaceArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getTableNamesByNamespace", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := THBaseServiceGetTableNamesByNamespaceResult{}
	var retval []*TTableName
	var err2 error
	if retval, err2 = p.handler.GetTableNamesByNamespace(args.Name); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getTableNamesByNamespace: "+err2.Error())
			oprot.WriteMessageBegin("getTableNamesByNamespace", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getTableNamesByNamespace", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorCreateTable struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorCreateTable) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := THBaseServiceCreateTableArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("createTable", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := THBaseServiceCreateTableResult{}
	var err2 error
	if err2 = p.handler.CreateTable(args.Desc, args.SplitKeys); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing createTable: "+err2.Error())
			oprot.WriteMessageBegin("createTable", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("createTable", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorDeleteTable struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorDeleteTable) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := THBaseServiceDeleteTableArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("deleteTable", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := THBaseServiceDeleteTableResult{}
	var err2 error
	if err2 = p.handler.DeleteTable(args.TableName); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing deleteTable: "+err2.Error())
			oprot.WriteMessageBegin("deleteTable", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("deleteTable", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorTruncateTable struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorTruncateTable) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := THBaseServiceTruncateTableArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("truncateTable", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := THBaseServiceTruncateTableResult{}
	var err2 error
	if err2 = p.handler.TruncateTable(args.TableName, args.PreserveSplits); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing truncateTable: "+err2.Error())
			oprot.WriteMessageBegin("truncateTable", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("truncateTable", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorEnableTable struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorEnableTable) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := THBaseServiceEnableTableArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("enableTable", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := THBaseServiceEnableTableResult{}
	var err2 error
	if err2 = p.handler.EnableTable(args.TableName); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing enableTable: "+err2.Error())
			oprot.WriteMessageBegin("enableTable", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("enableTable", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorDisableTable struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorDisableTable) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := THBaseServiceDisableTableArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("disableTable", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := THBaseServiceDisableTableResult{}
	var err2 error
	if err2 = p.handler.DisableTable(args.TableName); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing disableTable: "+err2.Error())
			oprot.WriteMessageBegin("disableTable", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("disableTable", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorIsTableEnabled struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorIsTableEnabled) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := THBaseServiceIsTableEnabledArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("isTableEnabled", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := THBaseServiceIsTableEnabledResult{}
	var retval bool
	var err2 error
	if retval, err2 = p.handler.IsTableEnabled(args.TableName); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing isTableEnabled: "+err2.Error())
			oprot.WriteMessageBegin("isTableEnabled", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("isTableEnabled", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorIsTableDisabled struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorIsTableDisabled) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := THBaseServiceIsTableDisabledArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("isTableDisabled", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := THBaseServiceIsTableDisabledResult{}
	var retval bool
	var err2 error
	if retval, err2 = p.handler.IsTableDisabled(args.TableName); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing isTableDisabled: "+err2.Error())
			oprot.WriteMessageBegin("isTableDisabled", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("isTableDisabled", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorIsTableAvailable struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorIsTableAvailable) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := THBaseServiceIsTableAvailableArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("isTableAvailable", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := THBaseServiceIsTableAvailableResult{}
	var retval bool
	var err2 error
	if retval, err2 = p.handler.IsTableAvailable(args.TableName); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing isTableAvailable: "+err2.Error())
			oprot.WriteMessageBegin("isTableAvailable", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("isTableAvailable", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorIsTableAvailableWithSplit struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorIsTableAvailableWithSplit) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := THBaseServiceIsTableAvailableWithSplitArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("isTableAvailableWithSplit", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := THBaseServiceIsTableAvailableWithSplitResult{}
	var retval bool
	var err2 error
	if retval, err2 = p.handler.IsTableAvailableWithSplit(args.TableName, args.SplitKeys); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing isTableAvailableWithSplit: "+err2.Error())
			oprot.WriteMessageBegin("isTableAvailableWithSplit", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("isTableAvailableWithSplit", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorAddColumnFamily struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorAddColumnFamily) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := THBaseServiceAddColumnFamilyArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("addColumnFamily", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := THBaseServiceAddColumnFamilyResult{}
	var err2 error
	if err2 = p.handler.AddColumnFamily(args.TableName, args.Column); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing addColumnFamily: "+err2.Error())
			oprot.WriteMessageBegin("addColumnFamily", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("addColumnFamily", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorDeleteColumnFamily struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorDeleteColumnFamily) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := THBaseServiceDeleteColumnFamilyArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("deleteColumnFamily", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := THBaseServiceDeleteColumnFamilyResult{}
	var err2 error
	if err2 = p.handler.DeleteColumnFamily(args.TableName, args.Column); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing deleteColumnFamily: "+err2.Error())
			oprot.WriteMessageBegin("deleteColumnFamily", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("deleteColumnFamily", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorModifyColumnFamily struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorModifyColumnFamily) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := THBaseServiceModifyColumnFamilyArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("modifyColumnFamily", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := THBaseServiceModifyColumnFamilyResult{}
	var err2 error
	if err2 = p.handler.ModifyColumnFamily(args.TableName, args.Column); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing modifyColumnFamily: "+err2.Error())
			oprot.WriteMessageBegin("modifyColumnFamily", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("modifyColumnFamily", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorModifyTable struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorModifyTable) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := THBaseServiceModifyTableArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("modifyTable", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := THBaseServiceModifyTableResult{}
	var err2 error
	if err2 = p.handler.ModifyTable(args.Desc); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing modifyTable: "+err2.Error())
			oprot.WriteMessageBegin("modifyTable", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("modifyTable", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorCreateNamespace struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorCreateNamespace) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := THBaseServiceCreateNamespaceArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("createNamespace", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := THBaseServiceCreateNamespaceResult{}
	var err2 error
	if err2 = p.handler.CreateNamespace(args.NamespaceDesc); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing createNamespace: "+err2.Error())
			oprot.WriteMessageBegin("createNamespace", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("createNamespace", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorModifyNamespace struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorModifyNamespace) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := THBaseServiceModifyNamespaceArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("modifyNamespace", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := THBaseServiceModifyNamespaceResult{}
	var err2 error
	if err2 = p.handler.ModifyNamespace(args.NamespaceDesc); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing modifyNamespace: "+err2.Error())
			oprot.WriteMessageBegin("modifyNamespace", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("modifyNamespace", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorDeleteNamespace struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorDeleteNamespace) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := THBaseServiceDeleteNamespaceArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("deleteNamespace", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := THBaseServiceDeleteNamespaceResult{}
	var err2 error
	if err2 = p.handler.DeleteNamespace(args.Name); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing deleteNamespace: "+err2.Error())
			oprot.WriteMessageBegin("deleteNamespace", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("deleteNamespace", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorGetNamespaceDescriptor struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorGetNamespaceDescriptor) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := THBaseServiceGetNamespaceDescriptorArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getNamespaceDescriptor", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := THBaseServiceGetNamespaceDescriptorResult{}
	var retval *TNamespaceDescriptor
	var err2 error
	if retval, err2 = p.handler.GetNamespaceDescriptor(args.Name); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getNamespaceDescriptor: "+err2.Error())
			oprot.WriteMessageBegin("getNamespaceDescriptor", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getNamespaceDescriptor", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorListNamespaceDescriptors struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorListNamespaceDescriptors) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := THBaseServiceListNamespaceDescriptorsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("listNamespaceDescriptors", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := THBaseServiceListNamespaceDescriptorsResult{}
	var retval []*TNamespaceDescriptor
	var err2 error
	if retval, err2 = p.handler.ListNamespaceDescriptors(); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing listNamespaceDescriptors: "+err2.Error())
			oprot.WriteMessageBegin("listNamespaceDescriptors", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("listNamespaceDescriptors", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

// HELPER FUNCTIONS AND STRUCTURES

// Attributes:
//  - Table: the table to check on
//  - Tget: the TGet to check for
type THBaseServiceExistsArgs struct {
	Table []byte `thrift:"table,1,required" json:"table"`
	Tget  *TGet  `thrift:"tget,2,required" json:"tget"`
}

func NewTHBaseServiceExistsArgs() *THBaseServiceExistsArgs {
	return &THBaseServiceExistsArgs{}
}

func (p *THBaseServiceExistsArgs) GetTable() []byte {
	return p.Table
}

var THBaseServiceExistsArgs_Tget_DEFAULT *TGet

func (p *THBaseServiceExistsArgs) GetTget() *TGet {
	if !p.IsSetTget() {
		return THBaseServiceExistsArgs_Tget_DEFAULT
	}
	return p.Tget
}
func (p *THBaseServiceExistsArgs) IsSetTget() bool {
	return p.Tget != nil
}

func (p *THBaseServiceExistsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTable bool = false
	var issetTget bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetTable = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetTget = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTable {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"))
	}
	if !issetTget {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Tget is not set"))
	}
	return nil
}

func (p *THBaseServiceExistsArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *THBaseServiceExistsArgs) readField2(iprot thrift.TProtocol) error {
	p.Tget = &TGet{}
	if err := p.Tget.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Tget), err)
	}
	return nil
}

func (p *THBaseServiceExistsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("exists_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceExistsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err)
	}
	if err := oprot.WriteBinary(p.Table); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.table (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err)
	}
	return err
}

func (p *THBaseServiceExistsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tget", thrift.STRUCT, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tget: ", p), err)
	}
	if err := p.Tget.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Tget), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tget: ", p), err)
	}
	return err
}

func (p *THBaseServiceExistsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceExistsArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceExistsResult struct {
	Success *bool     `thrift:"success,0" json:"success,omitempty"`
	Io      *TIOError `thrift:"io,1" json:"io,omitempty"`
}

func NewTHBaseServiceExistsResult() *THBaseServiceExistsResult {
	return &THBaseServiceExistsResult{}
}

var THBaseServiceExistsResult_Success_DEFAULT bool

func (p *THBaseServiceExistsResult) GetSuccess() bool {
	if !p.IsSetSuccess() {
		return THBaseServiceExistsResult_Success_DEFAULT
	}
	return *p.Success
}

var THBaseServiceExistsResult_Io_DEFAULT *TIOError

func (p *THBaseServiceExistsResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceExistsResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceExistsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceExistsResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceExistsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceExistsResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return thrift.PrependError("error reading field 0: ", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *THBaseServiceExistsResult) readField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceExistsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("exists_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceExistsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.BOOL, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteBool(bool(*p.Success)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceExistsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceExistsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceExistsResult(%+v)", *p)
}

// Attributes:
//  - Table: the table to check on
//  - Tgets: a list of TGets to check for
type THBaseServiceExistsAllArgs struct {
	Table []byte  `thrift:"table,1,required" json:"table"`
	Tgets []*TGet `thrift:"tgets,2,required" json:"tgets"`
}

func NewTHBaseServiceExistsAllArgs() *THBaseServiceExistsAllArgs {
	return &THBaseServiceExistsAllArgs{}
}

func (p *THBaseServiceExistsAllArgs) GetTable() []byte {
	return p.Table
}

func (p *THBaseServiceExistsAllArgs) GetTgets() []*TGet {
	return p.Tgets
}
func (p *THBaseServiceExistsAllArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTable bool = false
	var issetTgets bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetTable = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetTgets = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTable {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"))
	}
	if !issetTgets {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Tgets is not set"))
	}
	return nil
}

func (p *THBaseServiceExistsAllArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *THBaseServiceExistsAllArgs) readField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*TGet, 0, size)
	p.Tgets = tSlice
	for i := 0; i < size; i++ {
		_elem124 := &TGet{}
		if err := _elem124.Read(iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem124), err)
		}
		p.Tgets = append(p.Tgets, _elem124)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *THBaseServiceExistsAllArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("existsAll_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceExistsAllArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err)
	}
	if err := oprot.WriteBinary(p.Table); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.table (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err)
	}
	return err
}

func (p *THBaseServiceExistsAllArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tgets", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tgets: ", p), err)
	}
	if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Tgets)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Tgets {
		if err := v.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tgets: ", p), err)
	}
	return err
}

func (p *THBaseServiceExistsAllArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceExistsAllArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceExistsAllResult struct {
	Success []bool    `thrift:"success,0" json:"success,omitempty"`
	Io      *TIOError `thrift:"io,1" json:"io,omitempty"`
}

func NewTHBaseServiceExistsAllResult() *THBaseServiceExistsAllResult {
	return &THBaseServiceExistsAllResult{}
}

var THBaseServiceExistsAllResult_Success_DEFAULT []bool

func (p *THBaseServiceExistsAllResult) GetSuccess() []bool {
	return p.Success
}

var THBaseServiceExistsAllResult_Io_DEFAULT *TIOError

func (p *THBaseServiceExistsAllResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceExistsAllResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceExistsAllResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceExistsAllResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceExistsAllResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceExistsAllResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]bool, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		var _elem125 bool
		if v, err := iprot.ReadBool(); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem125 = v
		}
		p.Success = append(p.Success, _elem125)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *THBaseServiceExistsAllResult) readField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceExistsAllResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("existsAll_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceExistsAllResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteListBegin(thrift.BOOL, len(p.Success)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.Success {
			if err := oprot.WriteBool(bool(v)); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceExistsAllResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceExistsAllResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceExistsAllResult(%+v)", *p)
}

// Attributes:
//  - Table: the table to get from
//  - Tget: the TGet to fetch
type THBaseServiceGetArgs struct {
	Table []byte `thrift:"table,1,required" json:"table"`
	Tget  *TGet  `thrift:"tget,2,required" json:"tget"`
}

func NewTHBaseServiceGetArgs() *THBaseServiceGetArgs {
	return &THBaseServiceGetArgs{}
}

func (p *THBaseServiceGetArgs) GetTable() []byte {
	return p.Table
}

var THBaseServiceGetArgs_Tget_DEFAULT *TGet

func (p *THBaseServiceGetArgs) GetTget() *TGet {
	if !p.IsSetTget() {
		return THBaseServiceGetArgs_Tget_DEFAULT
	}
	return p.Tget
}
func (p *THBaseServiceGetArgs) IsSetTget() bool {
	return p.Tget != nil
}

func (p *THBaseServiceGetArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTable bool = false
	var issetTget bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetTable = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetTget = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTable {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"))
	}
	if !issetTget {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Tget is not set"))
	}
	return nil
}

func (p *THBaseServiceGetArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *THBaseServiceGetArgs) readField2(iprot thrift.TProtocol) error {
	p.Tget = &TGet{}
	if err := p.Tget.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Tget), err)
	}
	return nil
}

func (p *THBaseServiceGetArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceGetArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err)
	}
	if err := oprot.WriteBinary(p.Table); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.table (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err)
	}
	return err
}

func (p *THBaseServiceGetArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tget", thrift.STRUCT, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tget: ", p), err)
	}
	if err := p.Tget.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Tget), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tget: ", p), err)
	}
	return err
}

func (p *THBaseServiceGetArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceGetArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceGetResult struct {
	Success *TResult_ `thrift:"success,0" json:"success,omitempty"`
	Io      *TIOError `thrift:"io,1" json:"io,omitempty"`
}

func NewTHBaseServiceGetResult() *THBaseServiceGetResult {
	return &THBaseServiceGetResult{}
}

var THBaseServiceGetResult_Success_DEFAULT *TResult_

func (p *THBaseServiceGetResult) GetSuccess() *TResult_ {
	if !p.IsSetSuccess() {
		return THBaseServiceGetResult_Success_DEFAULT
	}
	return p.Success
}

var THBaseServiceGetResult_Io_DEFAULT *TIOError

func (p *THBaseServiceGetResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceGetResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceGetResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceGetResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceGetResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceGetResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &TResult_{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *THBaseServiceGetResult) readField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceGetResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceGetResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceGetResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceGetResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceGetResult(%+v)", *p)
}

// Attributes:
//  - Table: the table to get from
//  - Tgets: a list of TGets to fetch, the Result list
// will have the Results at corresponding positions
// or null if there was an error
type THBaseServiceGetMultipleArgs struct {
	Table []byte  `thrift:"table,1,required" json:"table"`
	Tgets []*TGet `thrift:"tgets,2,required" json:"tgets"`
}

func NewTHBaseServiceGetMultipleArgs() *THBaseServiceGetMultipleArgs {
	return &THBaseServiceGetMultipleArgs{}
}

func (p *THBaseServiceGetMultipleArgs) GetTable() []byte {
	return p.Table
}

func (p *THBaseServiceGetMultipleArgs) GetTgets() []*TGet {
	return p.Tgets
}
func (p *THBaseServiceGetMultipleArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTable bool = false
	var issetTgets bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetTable = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetTgets = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTable {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"))
	}
	if !issetTgets {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Tgets is not set"))
	}
	return nil
}

func (p *THBaseServiceGetMultipleArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *THBaseServiceGetMultipleArgs) readField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*TGet, 0, size)
	p.Tgets = tSlice
	for i := 0; i < size; i++ {
		_elem126 := &TGet{}
		if err := _elem126.Read(iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem126), err)
		}
		p.Tgets = append(p.Tgets, _elem126)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *THBaseServiceGetMultipleArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getMultiple_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceGetMultipleArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err)
	}
	if err := oprot.WriteBinary(p.Table); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.table (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err)
	}
	return err
}

func (p *THBaseServiceGetMultipleArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tgets", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tgets: ", p), err)
	}
	if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Tgets)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Tgets {
		if err := v.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tgets: ", p), err)
	}
	return err
}

func (p *THBaseServiceGetMultipleArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceGetMultipleArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceGetMultipleResult struct {
	Success []*TResult_ `thrift:"success,0" json:"success,omitempty"`
	Io      *TIOError   `thrift:"io,1" json:"io,omitempty"`
}

func NewTHBaseServiceGetMultipleResult() *THBaseServiceGetMultipleResult {
	return &THBaseServiceGetMultipleResult{}
}

var THBaseServiceGetMultipleResult_Success_DEFAULT []*TResult_

func (p *THBaseServiceGetMultipleResult) GetSuccess() []*TResult_ {
	return p.Success
}

var THBaseServiceGetMultipleResult_Io_DEFAULT *TIOError

func (p *THBaseServiceGetMultipleResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceGetMultipleResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceGetMultipleResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceGetMultipleResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceGetMultipleResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceGetMultipleResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*TResult_, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem127 := &TResult_{}
		if err := _elem127.Read(iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem127), err)
		}
		p.Success = append(p.Success, _elem127)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *THBaseServiceGetMultipleResult) readField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceGetMultipleResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getMultiple_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceGetMultipleResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceGetMultipleResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceGetMultipleResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceGetMultipleResult(%+v)", *p)
}

// Attributes:
//  - Table: the table to put data in
//  - Tput: the TPut to put
type THBaseServicePutArgs struct {
	Table []byte `thrift:"table,1,required" json:"table"`
	Tput  *TPut  `thrift:"tput,2,required" json:"tput"`
}

func NewTHBaseServicePutArgs() *THBaseServicePutArgs {
	return &THBaseServicePutArgs{}
}

func (p *THBaseServicePutArgs) GetTable() []byte {
	return p.Table
}

var THBaseServicePutArgs_Tput_DEFAULT *TPut

func (p *THBaseServicePutArgs) GetTput() *TPut {
	if !p.IsSetTput() {
		return THBaseServicePutArgs_Tput_DEFAULT
	}
	return p.Tput
}
func (p *THBaseServicePutArgs) IsSetTput() bool {
	return p.Tput != nil
}

func (p *THBaseServicePutArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTable bool = false
	var issetTput bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetTable = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetTput = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTable {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"))
	}
	if !issetTput {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Tput is not set"))
	}
	return nil
}

func (p *THBaseServicePutArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *THBaseServicePutArgs) readField2(iprot thrift.TProtocol) error {
	p.Tput = &TPut{}
	if err := p.Tput.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Tput), err)
	}
	return nil
}

func (p *THBaseServicePutArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("put_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServicePutArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err)
	}
	if err := oprot.WriteBinary(p.Table); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.table (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err)
	}
	return err
}

func (p *THBaseServicePutArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tput", thrift.STRUCT, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tput: ", p), err)
	}
	if err := p.Tput.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Tput), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tput: ", p), err)
	}
	return err
}

func (p *THBaseServicePutArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServicePutArgs(%+v)", *p)
}

// Attributes:
//  - Io
type THBaseServicePutResult struct {
	Io *TIOError `thrift:"io,1" json:"io,omitempty"`
}

func NewTHBaseServicePutResult() *THBaseServicePutResult {
	return &THBaseServicePutResult{}
}

var THBaseServicePutResult_Io_DEFAULT *TIOError

func (p *THBaseServicePutResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServicePutResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServicePutResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServicePutResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServicePutResult) readField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServicePutResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("put_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServicePutResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServicePutResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServicePutResult(%+v)", *p)
}

// Attributes:
//  - Table: to check in and put to
//  - Row: row to check
//  - Family: column family to check
//  - Qualifier: column qualifier to check
//  - Value: the expected value, if not provided the
// check is for the non-existence of the
// column in question
//  - Tput: the TPut to put if the check succeeds
type THBaseServiceCheckAndPutArgs struct {
	Table     []byte `thrift:"table,1,required" json:"table"`
	Row       []byte `thrift:"row,2,required" json:"row"`
	Family    []byte `thrift:"family,3,required" json:"family"`
	Qualifier []byte `thrift:"qualifier,4,required" json:"qualifier"`
	Value     []byte `thrift:"value,5" json:"value"`
	Tput      *TPut  `thrift:"tput,6,required" json:"tput"`
}

func NewTHBaseServiceCheckAndPutArgs() *THBaseServiceCheckAndPutArgs {
	return &THBaseServiceCheckAndPutArgs{}
}

func (p *THBaseServiceCheckAndPutArgs) GetTable() []byte {
	return p.Table
}

func (p *THBaseServiceCheckAndPutArgs) GetRow() []byte {
	return p.Row
}

func (p *THBaseServiceCheckAndPutArgs) GetFamily() []byte {
	return p.Family
}

func (p *THBaseServiceCheckAndPutArgs) GetQualifier() []byte {
	return p.Qualifier
}

func (p *THBaseServiceCheckAndPutArgs) GetValue() []byte {
	return p.Value
}

var THBaseServiceCheckAndPutArgs_Tput_DEFAULT *TPut

func (p *THBaseServiceCheckAndPutArgs) GetTput() *TPut {
	if !p.IsSetTput() {
		return THBaseServiceCheckAndPutArgs_Tput_DEFAULT
	}
	return p.Tput
}
func (p *THBaseServiceCheckAndPutArgs) IsSetTput() bool {
	return p.Tput != nil
}

func (p *THBaseServiceCheckAndPutArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTable bool = false
	var issetRow bool = false
	var issetFamily bool = false
	var issetQualifier bool = false
	var issetTput bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetTable = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetRow = true
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
			issetFamily = true
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
			issetQualifier = true
		case 5:
			if err := p.readField5(iprot); err != nil {
				return err
			}
		case 6:
			if err := p.readField6(iprot); err != nil {
				return err
			}
			issetTput = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTable {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"))
	}
	if !issetRow {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Row is not set"))
	}
	if !issetFamily {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Family is not set"))
	}
	if !issetQualifier {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Qualifier is not set"))
	}
	if !issetTput {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Tput is not set"))
	}
	return nil
}

func (p *THBaseServiceCheckAndPutArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *THBaseServiceCheckAndPutArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Row = v
	}
	return nil
}

func (p *THBaseServiceCheckAndPutArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.Family = v
	}
	return nil
}

func (p *THBaseServiceCheckAndPutArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.Qualifier = v
	}
	return nil
}

func (p *THBaseServiceCheckAndPutArgs) readField5(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 5: ", err)
	} else {
		p.Value = v
	}
	return nil
}

func (p *THBaseServiceCheckAndPutArgs) readField6(iprot thrift.TProtocol) error {
	p.Tput = &TPut{}
	if err := p.Tput.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Tput), err)
	}
	return nil
}

func (p *THBaseServiceCheckAndPutArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("checkAndPut_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := p.writeField6(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceCheckAndPutArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err)
	}
	if err := oprot.WriteBinary(p.Table); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.table (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err)
	}
	return err
}

func (p *THBaseServiceCheckAndPutArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("row", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:row: ", p), err)
	}
	if err := oprot.WriteBinary(p.Row); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.row (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:row: ", p), err)
	}
	return err
}

func (p *THBaseServiceCheckAndPutArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("family", thrift.STRING, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:family: ", p), err)
	}
	if err := oprot.WriteBinary(p.Family); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.family (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:family: ", p), err)
	}
	return err
}

func (p *THBaseServiceCheckAndPutArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("qualifier", thrift.STRING, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:qualifier: ", p), err)
	}
	if err := oprot.WriteBinary(p.Qualifier); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.qualifier (4) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:qualifier: ", p), err)
	}
	return err
}

func (p *THBaseServiceCheckAndPutArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("value", thrift.STRING, 5); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:value: ", p), err)
	}
	if err := oprot.WriteBinary(p.Value); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.value (5) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 5:value: ", p), err)
	}
	return err
}

func (p *THBaseServiceCheckAndPutArgs) writeField6(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tput", thrift.STRUCT, 6); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:tput: ", p), err)
	}
	if err := p.Tput.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Tput), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 6:tput: ", p), err)
	}
	return err
}

func (p *THBaseServiceCheckAndPutArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceCheckAndPutArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceCheckAndPutResult struct {
	Success *bool     `thrift:"success,0" json:"success,omitempty"`
	Io      *TIOError `thrift:"io,1" json:"io,omitempty"`
}

func NewTHBaseServiceCheckAndPutResult() *THBaseServiceCheckAndPutResult {
	return &THBaseServiceCheckAndPutResult{}
}

var THBaseServiceCheckAndPutResult_Success_DEFAULT bool

func (p *THBaseServiceCheckAndPutResult) GetSuccess() bool {
	if !p.IsSetSuccess() {
		return THBaseServiceCheckAndPutResult_Success_DEFAULT
	}
	return *p.Success
}

var THBaseServiceCheckAndPutResult_Io_DEFAULT *TIOError

func (p *THBaseServiceCheckAndPutResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceCheckAndPutResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceCheckAndPutResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceCheckAndPutResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceCheckAndPutResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceCheckAndPutResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return thrift.PrependError("error reading field 0: ", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *THBaseServiceCheckAndPutResult) readField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceCheckAndPutResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("checkAndPut_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceCheckAndPutResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.BOOL, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteBool(bool(*p.Success)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceCheckAndPutResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceCheckAndPutResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceCheckAndPutResult(%+v)", *p)
}

// Attributes:
//  - Table: the table to put data in
//  - Tputs: a list of TPuts to commit
type THBaseServicePutMultipleArgs struct {
	Table []byte  `thrift:"table,1,required" json:"table"`
	Tputs []*TPut `thrift:"tputs,2,required" json:"tputs"`
}

func NewTHBaseServicePutMultipleArgs() *THBaseServicePutMultipleArgs {
	return &THBaseServicePutMultipleArgs{}
}

func (p *THBaseServicePutMultipleArgs) GetTable() []byte {
	return p.Table
}

func (p *THBaseServicePutMultipleArgs) GetTputs() []*TPut {
	return p.Tputs
}
func (p *THBaseServicePutMultipleArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTable bool = false
	var issetTputs bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetTable = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetTputs = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTable {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"))
	}
	if !issetTputs {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Tputs is not set"))
	}
	return nil
}

func (p *THBaseServicePutMultipleArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *THBaseServicePutMultipleArgs) readField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*TPut, 0, size)
	p.Tputs = tSlice
	for i := 0; i < size; i++ {
		_elem128 := &TPut{}
		if err := _elem128.Read(iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem128), err)
		}
		p.Tputs = append(p.Tputs, _elem128)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *THBaseServicePutMultipleArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("putMultiple_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServicePutMultipleArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err)
	}
	if err := oprot.WriteBinary(p.Table); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.table (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err)
	}
	return err
}

func (p *THBaseServicePutMultipleArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tputs", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tputs: ", p), err)
	}
	if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Tputs)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Tputs {
		if err := v.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tputs: ", p), err)
	}
	return err
}

func (p *THBaseServicePutMultipleArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServicePutMultipleArgs(%+v)", *p)
}

// Attributes:
//  - Io
type THBaseServicePutMultipleResult struct {
	Io *TIOError `thrift:"io,1" json:"io,omitempty"`
}

func NewTHBaseServicePutMultipleResult() *THBaseServicePutMultipleResult {
	return &THBaseServicePutMultipleResult{}
}

var THBaseServicePutMultipleResult_Io_DEFAULT *TIOError

func (p *THBaseServicePutMultipleResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServicePutMultipleResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServicePutMultipleResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServicePutMultipleResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServicePutMultipleResult) readField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServicePutMultipleResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("putMultiple_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServicePutMultipleResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServicePutMultipleResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServicePutMultipleResult(%+v)", *p)
}

// Attributes:
//  - Table: the table to delete from
//  - Tdelete: the TDelete to delete
type THBaseServiceDeleteSingleArgs struct {
	Table   []byte   `thrift:"table,1,required" json:"table"`
	Tdelete *TDelete `thrift:"tdelete,2,required" json:"tdelete"`
}

func NewTHBaseServiceDeleteSingleArgs() *THBaseServiceDeleteSingleArgs {
	return &THBaseServiceDeleteSingleArgs{}
}

func (p *THBaseServiceDeleteSingleArgs) GetTable() []byte {
	return p.Table
}

var THBaseServiceDeleteSingleArgs_Tdelete_DEFAULT *TDelete

func (p *THBaseServiceDeleteSingleArgs) GetTdelete() *TDelete {
	if !p.IsSetTdelete() {
		return THBaseServiceDeleteSingleArgs_Tdelete_DEFAULT
	}
	return p.Tdelete
}
func (p *THBaseServiceDeleteSingleArgs) IsSetTdelete() bool {
	return p.Tdelete != nil
}

func (p *THBaseServiceDeleteSingleArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTable bool = false
	var issetTdelete bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetTable = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetTdelete = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTable {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"))
	}
	if !issetTdelete {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Tdelete is not set"))
	}
	return nil
}

func (p *THBaseServiceDeleteSingleArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *THBaseServiceDeleteSingleArgs) readField2(iprot thrift.TProtocol) error {
	p.Tdelete = &TDelete{
		DeleteType: 1,
	}
	if err := p.Tdelete.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Tdelete), err)
	}
	return nil
}

func (p *THBaseServiceDeleteSingleArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteSingle_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceDeleteSingleArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err)
	}
	if err := oprot.WriteBinary(p.Table); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.table (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err)
	}
	return err
}

func (p *THBaseServiceDeleteSingleArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tdelete", thrift.STRUCT, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tdelete: ", p), err)
	}
	if err := p.Tdelete.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Tdelete), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tdelete: ", p), err)
	}
	return err
}

func (p *THBaseServiceDeleteSingleArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceDeleteSingleArgs(%+v)", *p)
}

// Attributes:
//  - Io
type THBaseServiceDeleteSingleResult struct {
	Io *TIOError `thrift:"io,1" json:"io,omitempty"`
}

func NewTHBaseServiceDeleteSingleResult() *THBaseServiceDeleteSingleResult {
	return &THBaseServiceDeleteSingleResult{}
}

var THBaseServiceDeleteSingleResult_Io_DEFAULT *TIOError

func (p *THBaseServiceDeleteSingleResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceDeleteSingleResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceDeleteSingleResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceDeleteSingleResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceDeleteSingleResult) readField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceDeleteSingleResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteSingle_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceDeleteSingleResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceDeleteSingleResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceDeleteSingleResult(%+v)", *p)
}

// Attributes:
//  - Table: the table to delete from
//  - Tdeletes: list of TDeletes to delete
type THBaseServiceDeleteMultipleArgs struct {
	Table    []byte     `thrift:"table,1,required" json:"table"`
	Tdeletes []*TDelete `thrift:"tdeletes,2,required" json:"tdeletes"`
}

func NewTHBaseServiceDeleteMultipleArgs() *THBaseServiceDeleteMultipleArgs {
	return &THBaseServiceDeleteMultipleArgs{}
}

func (p *THBaseServiceDeleteMultipleArgs) GetTable() []byte {
	return p.Table
}

func (p *THBaseServiceDeleteMultipleArgs) GetTdeletes() []*TDelete {
	return p.Tdeletes
}
func (p *THBaseServiceDeleteMultipleArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTable bool = false
	var issetTdeletes bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetTable = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetTdeletes = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTable {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"))
	}
	if !issetTdeletes {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Tdeletes is not set"))
	}
	return nil
}

func (p *THBaseServiceDeleteMultipleArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *THBaseServiceDeleteMultipleArgs) readField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*TDelete, 0, size)
	p.Tdeletes = tSlice
	for i := 0; i < size; i++ {
		_elem129 := &TDelete{
			DeleteType: 1,
		}
		if err := _elem129.Read(iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem129), err)
		}
		p.Tdeletes = append(p.Tdeletes, _elem129)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *THBaseServiceDeleteMultipleArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteMultiple_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceDeleteMultipleArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err)
	}
	if err := oprot.WriteBinary(p.Table); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.table (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err)
	}
	return err
}

func (p *THBaseServiceDeleteMultipleArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tdeletes", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tdeletes: ", p), err)
	}
	if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Tdeletes)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Tdeletes {
		if err := v.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tdeletes: ", p), err)
	}
	return err
}

func (p *THBaseServiceDeleteMultipleArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceDeleteMultipleArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceDeleteMultipleResult struct {
	Success []*TDelete `thrift:"success,0" json:"success,omitempty"`
	Io      *TIOError  `thrift:"io,1" json:"io,omitempty"`
}

func NewTHBaseServiceDeleteMultipleResult() *THBaseServiceDeleteMultipleResult {
	return &THBaseServiceDeleteMultipleResult{}
}

var THBaseServiceDeleteMultipleResult_Success_DEFAULT []*TDelete

func (p *THBaseServiceDeleteMultipleResult) GetSuccess() []*TDelete {
	return p.Success
}

var THBaseServiceDeleteMultipleResult_Io_DEFAULT *TIOError

func (p *THBaseServiceDeleteMultipleResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceDeleteMultipleResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceDeleteMultipleResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceDeleteMultipleResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceDeleteMultipleResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceDeleteMultipleResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*TDelete, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem130 := &TDelete{
			DeleteType: 1,
		}
		if err := _elem130.Read(iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem130), err)
		}
		p.Success = append(p.Success, _elem130)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *THBaseServiceDeleteMultipleResult) readField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceDeleteMultipleResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteMultiple_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceDeleteMultipleResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceDeleteMultipleResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceDeleteMultipleResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceDeleteMultipleResult(%+v)", *p)
}

// Attributes:
//  - Table: to check in and delete from
//  - Row: row to check
//  - Family: column family to check
//  - Qualifier: column qualifier to check
//  - Value: the expected value, if not provided the
// check is for the non-existence of the
// column in question
//  - Tdelete: the TDelete to execute if the check succeeds
type THBaseServiceCheckAndDeleteArgs struct {
	Table     []byte   `thrift:"table,1,required" json:"table"`
	Row       []byte   `thrift:"row,2,required" json:"row"`
	Family    []byte   `thrift:"family,3,required" json:"family"`
	Qualifier []byte   `thrift:"qualifier,4,required" json:"qualifier"`
	Value     []byte   `thrift:"value,5" json:"value"`
	Tdelete   *TDelete `thrift:"tdelete,6,required" json:"tdelete"`
}

func NewTHBaseServiceCheckAndDeleteArgs() *THBaseServiceCheckAndDeleteArgs {
	return &THBaseServiceCheckAndDeleteArgs{}
}

func (p *THBaseServiceCheckAndDeleteArgs) GetTable() []byte {
	return p.Table
}

func (p *THBaseServiceCheckAndDeleteArgs) GetRow() []byte {
	return p.Row
}

func (p *THBaseServiceCheckAndDeleteArgs) GetFamily() []byte {
	return p.Family
}

func (p *THBaseServiceCheckAndDeleteArgs) GetQualifier() []byte {
	return p.Qualifier
}

func (p *THBaseServiceCheckAndDeleteArgs) GetValue() []byte {
	return p.Value
}

var THBaseServiceCheckAndDeleteArgs_Tdelete_DEFAULT *TDelete

func (p *THBaseServiceCheckAndDeleteArgs) GetTdelete() *TDelete {
	if !p.IsSetTdelete() {
		return THBaseServiceCheckAndDeleteArgs_Tdelete_DEFAULT
	}
	return p.Tdelete
}
func (p *THBaseServiceCheckAndDeleteArgs) IsSetTdelete() bool {
	return p.Tdelete != nil
}

func (p *THBaseServiceCheckAndDeleteArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTable bool = false
	var issetRow bool = false
	var issetFamily bool = false
	var issetQualifier bool = false
	var issetTdelete bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetTable = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetRow = true
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
			issetFamily = true
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
			issetQualifier = true
		case 5:
			if err := p.readField5(iprot); err != nil {
				return err
			}
		case 6:
			if err := p.readField6(iprot); err != nil {
				return err
			}
			issetTdelete = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTable {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"))
	}
	if !issetRow {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Row is not set"))
	}
	if !issetFamily {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Family is not set"))
	}
	if !issetQualifier {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Qualifier is not set"))
	}
	if !issetTdelete {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Tdelete is not set"))
	}
	return nil
}

func (p *THBaseServiceCheckAndDeleteArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *THBaseServiceCheckAndDeleteArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Row = v
	}
	return nil
}

func (p *THBaseServiceCheckAndDeleteArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.Family = v
	}
	return nil
}

func (p *THBaseServiceCheckAndDeleteArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.Qualifier = v
	}
	return nil
}

func (p *THBaseServiceCheckAndDeleteArgs) readField5(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 5: ", err)
	} else {
		p.Value = v
	}
	return nil
}

func (p *THBaseServiceCheckAndDeleteArgs) readField6(iprot thrift.TProtocol) error {
	p.Tdelete = &TDelete{
		DeleteType: 1,
	}
	if err := p.Tdelete.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Tdelete), err)
	}
	return nil
}

func (p *THBaseServiceCheckAndDeleteArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("checkAndDelete_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := p.writeField6(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceCheckAndDeleteArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err)
	}
	if err := oprot.WriteBinary(p.Table); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.table (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err)
	}
	return err
}

func (p *THBaseServiceCheckAndDeleteArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("row", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:row: ", p), err)
	}
	if err := oprot.WriteBinary(p.Row); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.row (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:row: ", p), err)
	}
	return err
}

func (p *THBaseServiceCheckAndDeleteArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("family", thrift.STRING, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:family: ", p), err)
	}
	if err := oprot.WriteBinary(p.Family); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.family (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:family: ", p), err)
	}
	return err
}

func (p *THBaseServiceCheckAndDeleteArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("qualifier", thrift.STRING, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:qualifier: ", p), err)
	}
	if err := oprot.WriteBinary(p.Qualifier); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.qualifier (4) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:qualifier: ", p), err)
	}
	return err
}

func (p *THBaseServiceCheckAndDeleteArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("value", thrift.STRING, 5); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:value: ", p), err)
	}
	if err := oprot.WriteBinary(p.Value); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.value (5) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 5:value: ", p), err)
	}
	return err
}

func (p *THBaseServiceCheckAndDeleteArgs) writeField6(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tdelete", thrift.STRUCT, 6); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:tdelete: ", p), err)
	}
	if err := p.Tdelete.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Tdelete), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 6:tdelete: ", p), err)
	}
	return err
}

func (p *THBaseServiceCheckAndDeleteArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceCheckAndDeleteArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceCheckAndDeleteResult struct {
	Success *bool     `thrift:"success,0" json:"success,omitempty"`
	Io      *TIOError `thrift:"io,1" json:"io,omitempty"`
}

func NewTHBaseServiceCheckAndDeleteResult() *THBaseServiceCheckAndDeleteResult {
	return &THBaseServiceCheckAndDeleteResult{}
}

var THBaseServiceCheckAndDeleteResult_Success_DEFAULT bool

func (p *THBaseServiceCheckAndDeleteResult) GetSuccess() bool {
	if !p.IsSetSuccess() {
		return THBaseServiceCheckAndDeleteResult_Success_DEFAULT
	}
	return *p.Success
}

var THBaseServiceCheckAndDeleteResult_Io_DEFAULT *TIOError

func (p *THBaseServiceCheckAndDeleteResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceCheckAndDeleteResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceCheckAndDeleteResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceCheckAndDeleteResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceCheckAndDeleteResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceCheckAndDeleteResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return thrift.PrependError("error reading field 0: ", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *THBaseServiceCheckAndDeleteResult) readField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceCheckAndDeleteResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("checkAndDelete_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceCheckAndDeleteResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.BOOL, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteBool(bool(*p.Success)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceCheckAndDeleteResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceCheckAndDeleteResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceCheckAndDeleteResult(%+v)", *p)
}

// Attributes:
//  - Table: the table to increment the value on
//  - Tincrement: the TIncrement to increment
type THBaseServiceIncrementArgs struct {
	Table      []byte      `thrift:"table,1,required" json:"table"`
	Tincrement *TIncrement `thrift:"tincrement,2,required" json:"tincrement"`
}

func NewTHBaseServiceIncrementArgs() *THBaseServiceIncrementArgs {
	return &THBaseServiceIncrementArgs{}
}

func (p *THBaseServiceIncrementArgs) GetTable() []byte {
	return p.Table
}

var THBaseServiceIncrementArgs_Tincrement_DEFAULT *TIncrement

func (p *THBaseServiceIncrementArgs) GetTincrement() *TIncrement {
	if !p.IsSetTincrement() {
		return THBaseServiceIncrementArgs_Tincrement_DEFAULT
	}
	return p.Tincrement
}
func (p *THBaseServiceIncrementArgs) IsSetTincrement() bool {
	return p.Tincrement != nil
}

func (p *THBaseServiceIncrementArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTable bool = false
	var issetTincrement bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetTable = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetTincrement = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTable {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"))
	}
	if !issetTincrement {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Tincrement is not set"))
	}
	return nil
}

func (p *THBaseServiceIncrementArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *THBaseServiceIncrementArgs) readField2(iprot thrift.TProtocol) error {
	p.Tincrement = &TIncrement{}
	if err := p.Tincrement.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Tincrement), err)
	}
	return nil
}

func (p *THBaseServiceIncrementArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("increment_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceIncrementArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err)
	}
	if err := oprot.WriteBinary(p.Table); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.table (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err)
	}
	return err
}

func (p *THBaseServiceIncrementArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tincrement", thrift.STRUCT, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tincrement: ", p), err)
	}
	if err := p.Tincrement.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Tincrement), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tincrement: ", p), err)
	}
	return err
}

func (p *THBaseServiceIncrementArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceIncrementArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceIncrementResult struct {
	Success *TResult_ `thrift:"success,0" json:"success,omitempty"`
	Io      *TIOError `thrift:"io,1" json:"io,omitempty"`
}

func NewTHBaseServiceIncrementResult() *THBaseServiceIncrementResult {
	return &THBaseServiceIncrementResult{}
}

var THBaseServiceIncrementResult_Success_DEFAULT *TResult_

func (p *THBaseServiceIncrementResult) GetSuccess() *TResult_ {
	if !p.IsSetSuccess() {
		return THBaseServiceIncrementResult_Success_DEFAULT
	}
	return p.Success
}

var THBaseServiceIncrementResult_Io_DEFAULT *TIOError

func (p *THBaseServiceIncrementResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceIncrementResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceIncrementResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceIncrementResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceIncrementResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceIncrementResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &TResult_{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *THBaseServiceIncrementResult) readField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceIncrementResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("increment_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceIncrementResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceIncrementResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceIncrementResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceIncrementResult(%+v)", *p)
}

// Attributes:
//  - Table: the table to append the value on
//  - Tappend: the TAppend to append
type THBaseServiceAppendArgs struct {
	Table   []byte   `thrift:"table,1,required" json:"table"`
	Tappend *TAppend `thrift:"tappend,2,required" json:"tappend"`
}

func NewTHBaseServiceAppendArgs() *THBaseServiceAppendArgs {
	return &THBaseServiceAppendArgs{}
}

func (p *THBaseServiceAppendArgs) GetTable() []byte {
	return p.Table
}

var THBaseServiceAppendArgs_Tappend_DEFAULT *TAppend

func (p *THBaseServiceAppendArgs) GetTappend() *TAppend {
	if !p.IsSetTappend() {
		return THBaseServiceAppendArgs_Tappend_DEFAULT
	}
	return p.Tappend
}
func (p *THBaseServiceAppendArgs) IsSetTappend() bool {
	return p.Tappend != nil
}

func (p *THBaseServiceAppendArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTable bool = false
	var issetTappend bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetTable = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetTappend = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTable {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"))
	}
	if !issetTappend {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Tappend is not set"))
	}
	return nil
}

func (p *THBaseServiceAppendArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *THBaseServiceAppendArgs) readField2(iprot thrift.TProtocol) error {
	p.Tappend = &TAppend{}
	if err := p.Tappend.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Tappend), err)
	}
	return nil
}

func (p *THBaseServiceAppendArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("append_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceAppendArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err)
	}
	if err := oprot.WriteBinary(p.Table); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.table (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err)
	}
	return err
}

func (p *THBaseServiceAppendArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tappend", thrift.STRUCT, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tappend: ", p), err)
	}
	if err := p.Tappend.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Tappend), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tappend: ", p), err)
	}
	return err
}

func (p *THBaseServiceAppendArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceAppendArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceAppendResult struct {
	Success *TResult_ `thrift:"success,0" json:"success,omitempty"`
	Io      *TIOError `thrift:"io,1" json:"io,omitempty"`
}

func NewTHBaseServiceAppendResult() *THBaseServiceAppendResult {
	return &THBaseServiceAppendResult{}
}

var THBaseServiceAppendResult_Success_DEFAULT *TResult_

func (p *THBaseServiceAppendResult) GetSuccess() *TResult_ {
	if !p.IsSetSuccess() {
		return THBaseServiceAppendResult_Success_DEFAULT
	}
	return p.Success
}

var THBaseServiceAppendResult_Io_DEFAULT *TIOError

func (p *THBaseServiceAppendResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceAppendResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceAppendResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceAppendResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceAppendResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceAppendResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &TResult_{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *THBaseServiceAppendResult) readField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceAppendResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("append_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceAppendResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceAppendResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceAppendResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceAppendResult(%+v)", *p)
}

// Attributes:
//  - Table: the table to get the Scanner for
//  - Tscan: the scan object to get a Scanner for
type THBaseServiceOpenScannerArgs struct {
	Table []byte `thrift:"table,1,required" json:"table"`
	Tscan *TScan `thrift:"tscan,2,required" json:"tscan"`
}

func NewTHBaseServiceOpenScannerArgs() *THBaseServiceOpenScannerArgs {
	return &THBaseServiceOpenScannerArgs{}
}

func (p *THBaseServiceOpenScannerArgs) GetTable() []byte {
	return p.Table
}

var THBaseServiceOpenScannerArgs_Tscan_DEFAULT *TScan

func (p *THBaseServiceOpenScannerArgs) GetTscan() *TScan {
	if !p.IsSetTscan() {
		return THBaseServiceOpenScannerArgs_Tscan_DEFAULT
	}
	return p.Tscan
}
func (p *THBaseServiceOpenScannerArgs) IsSetTscan() bool {
	return p.Tscan != nil
}

func (p *THBaseServiceOpenScannerArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTable bool = false
	var issetTscan bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetTable = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetTscan = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTable {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"))
	}
	if !issetTscan {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Tscan is not set"))
	}
	return nil
}

func (p *THBaseServiceOpenScannerArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *THBaseServiceOpenScannerArgs) readField2(iprot thrift.TProtocol) error {
	p.Tscan = &TScan{
		MaxVersions: 1,
	}
	if err := p.Tscan.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Tscan), err)
	}
	return nil
}

func (p *THBaseServiceOpenScannerArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("openScanner_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceOpenScannerArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err)
	}
	if err := oprot.WriteBinary(p.Table); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.table (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err)
	}
	return err
}

func (p *THBaseServiceOpenScannerArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tscan", thrift.STRUCT, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tscan: ", p), err)
	}
	if err := p.Tscan.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Tscan), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tscan: ", p), err)
	}
	return err
}

func (p *THBaseServiceOpenScannerArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceOpenScannerArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceOpenScannerResult struct {
	Success *int32    `thrift:"success,0" json:"success,omitempty"`
	Io      *TIOError `thrift:"io,1" json:"io,omitempty"`
}

func NewTHBaseServiceOpenScannerResult() *THBaseServiceOpenScannerResult {
	return &THBaseServiceOpenScannerResult{}
}

var THBaseServiceOpenScannerResult_Success_DEFAULT int32

func (p *THBaseServiceOpenScannerResult) GetSuccess() int32 {
	if !p.IsSetSuccess() {
		return THBaseServiceOpenScannerResult_Success_DEFAULT
	}
	return *p.Success
}

var THBaseServiceOpenScannerResult_Io_DEFAULT *TIOError

func (p *THBaseServiceOpenScannerResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceOpenScannerResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceOpenScannerResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceOpenScannerResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceOpenScannerResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceOpenScannerResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 0: ", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *THBaseServiceOpenScannerResult) readField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceOpenScannerResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("openScanner_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceOpenScannerResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.I32, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteI32(int32(*p.Success)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceOpenScannerResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceOpenScannerResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceOpenScannerResult(%+v)", *p)
}

// Attributes:
//  - ScannerId: the Id of the Scanner to return rows from. This is an Id returned from the openScanner function.
//  - NumRows: number of rows to return
type THBaseServiceGetScannerRowsArgs struct {
	ScannerId int32 `thrift:"scannerId,1,required" json:"scannerId"`
	NumRows   int32 `thrift:"numRows,2" json:"numRows"`
}

func NewTHBaseServiceGetScannerRowsArgs() *THBaseServiceGetScannerRowsArgs {
	return &THBaseServiceGetScannerRowsArgs{
		NumRows: 1,
	}
}

func (p *THBaseServiceGetScannerRowsArgs) GetScannerId() int32 {
	return p.ScannerId
}

func (p *THBaseServiceGetScannerRowsArgs) GetNumRows() int32 {
	return p.NumRows
}
func (p *THBaseServiceGetScannerRowsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetScannerId bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetScannerId = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetScannerId {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ScannerId is not set"))
	}
	return nil
}

func (p *THBaseServiceGetScannerRowsArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.ScannerId = v
	}
	return nil
}

func (p *THBaseServiceGetScannerRowsArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.NumRows = v
	}
	return nil
}

func (p *THBaseServiceGetScannerRowsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getScannerRows_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceGetScannerRowsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("scannerId", thrift.I32, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:scannerId: ", p), err)
	}
	if err := oprot.WriteI32(int32(p.ScannerId)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.scannerId (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:scannerId: ", p), err)
	}
	return err
}

func (p *THBaseServiceGetScannerRowsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("numRows", thrift.I32, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:numRows: ", p), err)
	}
	if err := oprot.WriteI32(int32(p.NumRows)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.numRows (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:numRows: ", p), err)
	}
	return err
}

func (p *THBaseServiceGetScannerRowsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceGetScannerRowsArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
//  - Ia: if the scannerId is invalid
type THBaseServiceGetScannerRowsResult struct {
	Success []*TResult_       `thrift:"success,0" json:"success,omitempty"`
	Io      *TIOError         `thrift:"io,1" json:"io,omitempty"`
	Ia      *TIllegalArgument `thrift:"ia,2" json:"ia,omitempty"`
}

func NewTHBaseServiceGetScannerRowsResult() *THBaseServiceGetScannerRowsResult {
	return &THBaseServiceGetScannerRowsResult{}
}

var THBaseServiceGetScannerRowsResult_Success_DEFAULT []*TResult_

func (p *THBaseServiceGetScannerRowsResult) GetSuccess() []*TResult_ {
	return p.Success
}

var THBaseServiceGetScannerRowsResult_Io_DEFAULT *TIOError

func (p *THBaseServiceGetScannerRowsResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceGetScannerRowsResult_Io_DEFAULT
	}
	return p.Io
}

var THBaseServiceGetScannerRowsResult_Ia_DEFAULT *TIllegalArgument

func (p *THBaseServiceGetScannerRowsResult) GetIa() *TIllegalArgument {
	if !p.IsSetIa() {
		return THBaseServiceGetScannerRowsResult_Ia_DEFAULT
	}
	return p.Ia
}
func (p *THBaseServiceGetScannerRowsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceGetScannerRowsResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceGetScannerRowsResult) IsSetIa() bool {
	return p.Ia != nil
}

func (p *THBaseServiceGetScannerRowsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceGetScannerRowsResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*TResult_, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem131 := &TResult_{}
		if err := _elem131.Read(iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem131), err)
		}
		p.Success = append(p.Success, _elem131)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *THBaseServiceGetScannerRowsResult) readField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceGetScannerRowsResult) readField2(iprot thrift.TProtocol) error {
	p.Ia = &TIllegalArgument{}
	if err := p.Ia.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ia), err)
	}
	return nil
}

func (p *THBaseServiceGetScannerRowsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getScannerRows_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceGetScannerRowsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceGetScannerRowsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceGetScannerRowsResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetIa() {
		if err := oprot.WriteFieldBegin("ia", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ia: ", p), err)
		}
		if err := p.Ia.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ia), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ia: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceGetScannerRowsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceGetScannerRowsResult(%+v)", *p)
}

// Attributes:
//  - ScannerId: the Id of the Scanner to close *
type THBaseServiceCloseScannerArgs struct {
	ScannerId int32 `thrift:"scannerId,1,required" json:"scannerId"`
}

func NewTHBaseServiceCloseScannerArgs() *THBaseServiceCloseScannerArgs {
	return &THBaseServiceCloseScannerArgs{}
}

func (p *THBaseServiceCloseScannerArgs) GetScannerId() int32 {
	return p.ScannerId
}
func (p *THBaseServiceCloseScannerArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetScannerId bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetScannerId = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetScannerId {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ScannerId is not set"))
	}
	return nil
}

func (p *THBaseServiceCloseScannerArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.ScannerId = v
	}
	return nil
}

func (p *THBaseServiceCloseScannerArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("closeScanner_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceCloseScannerArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("scannerId", thrift.I32, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:scannerId: ", p), err)
	}
	if err := oprot.WriteI32(int32(p.ScannerId)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.scannerId (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:scannerId: ", p), err)
	}
	return err
}

func (p *THBaseServiceCloseScannerArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceCloseScannerArgs(%+v)", *p)
}

// Attributes:
//  - Io
//  - Ia: if the scannerId is invalid
type THBaseServiceCloseScannerResult struct {
	Io *TIOError         `thrift:"io,1" json:"io,omitempty"`
	Ia *TIllegalArgument `thrift:"ia,2" json:"ia,omitempty"`
}

func NewTHBaseServiceCloseScannerResult() *THBaseServiceCloseScannerResult {
	return &THBaseServiceCloseScannerResult{}
}

var THBaseServiceCloseScannerResult_Io_DEFAULT *TIOError

func (p *THBaseServiceCloseScannerResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceCloseScannerResult_Io_DEFAULT
	}
	return p.Io
}

var THBaseServiceCloseScannerResult_Ia_DEFAULT *TIllegalArgument

func (p *THBaseServiceCloseScannerResult) GetIa() *TIllegalArgument {
	if !p.IsSetIa() {
		return THBaseServiceCloseScannerResult_Ia_DEFAULT
	}
	return p.Ia
}
func (p *THBaseServiceCloseScannerResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceCloseScannerResult) IsSetIa() bool {
	return p.Ia != nil
}

func (p *THBaseServiceCloseScannerResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceCloseScannerResult) readField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceCloseScannerResult) readField2(iprot thrift.TProtocol) error {
	p.Ia = &TIllegalArgument{}
	if err := p.Ia.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ia), err)
	}
	return nil
}

func (p *THBaseServiceCloseScannerResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("closeScanner_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceCloseScannerResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceCloseScannerResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetIa() {
		if err := oprot.WriteFieldBegin("ia", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ia: ", p), err)
		}
		if err := p.Ia.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ia), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ia: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceCloseScannerResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceCloseScannerResult(%+v)", *p)
}

// Attributes:
//  - Table: table to apply the mutations
//  - TrowMutations: mutations to apply
type THBaseServiceMutateRowArgs struct {
	Table         []byte         `thrift:"table,1,required" json:"table"`
	TrowMutations *TRowMutations `thrift:"trowMutations,2,required" json:"trowMutations"`
}

func NewTHBaseServiceMutateRowArgs() *THBaseServiceMutateRowArgs {
	return &THBaseServiceMutateRowArgs{}
}

func (p *THBaseServiceMutateRowArgs) GetTable() []byte {
	return p.Table
}

var THBaseServiceMutateRowArgs_TrowMutations_DEFAULT *TRowMutations

func (p *THBaseServiceMutateRowArgs) GetTrowMutations() *TRowMutations {
	if !p.IsSetTrowMutations() {
		return THBaseServiceMutateRowArgs_TrowMutations_DEFAULT
	}
	return p.TrowMutations
}
func (p *THBaseServiceMutateRowArgs) IsSetTrowMutations() bool {
	return p.TrowMutations != nil
}

func (p *THBaseServiceMutateRowArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTable bool = false
	var issetTrowMutations bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetTable = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetTrowMutations = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTable {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"))
	}
	if !issetTrowMutations {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TrowMutations is not set"))
	}
	return nil
}

func (p *THBaseServiceMutateRowArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *THBaseServiceMutateRowArgs) readField2(iprot thrift.TProtocol) error {
	p.TrowMutations = &TRowMutations{}
	if err := p.TrowMutations.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TrowMutations), err)
	}
	return nil
}

func (p *THBaseServiceMutateRowArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("mutateRow_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceMutateRowArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err)
	}
	if err := oprot.WriteBinary(p.Table); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.table (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err)
	}
	return err
}

func (p *THBaseServiceMutateRowArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("trowMutations", thrift.STRUCT, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:trowMutations: ", p), err)
	}
	if err := p.TrowMutations.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TrowMutations), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:trowMutations: ", p), err)
	}
	return err
}

func (p *THBaseServiceMutateRowArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceMutateRowArgs(%+v)", *p)
}

// Attributes:
//  - Io
type THBaseServiceMutateRowResult struct {
	Io *TIOError `thrift:"io,1" json:"io,omitempty"`
}

func NewTHBaseServiceMutateRowResult() *THBaseServiceMutateRowResult {
	return &THBaseServiceMutateRowResult{}
}

var THBaseServiceMutateRowResult_Io_DEFAULT *TIOError

func (p *THBaseServiceMutateRowResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceMutateRowResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceMutateRowResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceMutateRowResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceMutateRowResult) readField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceMutateRowResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("mutateRow_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceMutateRowResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceMutateRowResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceMutateRowResult(%+v)", *p)
}

// Attributes:
//  - Table: the table to get the Scanner for
//  - Tscan: the scan object to get a Scanner for
//  - NumRows: number of rows to return
type THBaseServiceGetScannerResultsArgs struct {
	Table   []byte `thrift:"table,1,required" json:"table"`
	Tscan   *TScan `thrift:"tscan,2,required" json:"tscan"`
	NumRows int32  `thrift:"numRows,3" json:"numRows"`
}

func NewTHBaseServiceGetScannerResultsArgs() *THBaseServiceGetScannerResultsArgs {
	return &THBaseServiceGetScannerResultsArgs{
		NumRows: 1,
	}
}

func (p *THBaseServiceGetScannerResultsArgs) GetTable() []byte {
	return p.Table
}

var THBaseServiceGetScannerResultsArgs_Tscan_DEFAULT *TScan

func (p *THBaseServiceGetScannerResultsArgs) GetTscan() *TScan {
	if !p.IsSetTscan() {
		return THBaseServiceGetScannerResultsArgs_Tscan_DEFAULT
	}
	return p.Tscan
}

func (p *THBaseServiceGetScannerResultsArgs) GetNumRows() int32 {
	return p.NumRows
}
func (p *THBaseServiceGetScannerResultsArgs) IsSetTscan() bool {
	return p.Tscan != nil
}

func (p *THBaseServiceGetScannerResultsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTable bool = false
	var issetTscan bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetTable = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetTscan = true
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTable {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"))
	}
	if !issetTscan {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Tscan is not set"))
	}
	return nil
}

func (p *THBaseServiceGetScannerResultsArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *THBaseServiceGetScannerResultsArgs) readField2(iprot thrift.TProtocol) error {
	p.Tscan = &TScan{
		MaxVersions: 1,
	}
	if err := p.Tscan.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Tscan), err)
	}
	return nil
}

func (p *THBaseServiceGetScannerResultsArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.NumRows = v
	}
	return nil
}

func (p *THBaseServiceGetScannerResultsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getScannerResults_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceGetScannerResultsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err)
	}
	if err := oprot.WriteBinary(p.Table); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.table (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err)
	}
	return err
}

func (p *THBaseServiceGetScannerResultsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tscan", thrift.STRUCT, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tscan: ", p), err)
	}
	if err := p.Tscan.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Tscan), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tscan: ", p), err)
	}
	return err
}

func (p *THBaseServiceGetScannerResultsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("numRows", thrift.I32, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:numRows: ", p), err)
	}
	if err := oprot.WriteI32(int32(p.NumRows)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.numRows (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:numRows: ", p), err)
	}
	return err
}

func (p *THBaseServiceGetScannerResultsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceGetScannerResultsArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceGetScannerResultsResult struct {
	Success []*TResult_ `thrift:"success,0" json:"success,omitempty"`
	Io      *TIOError   `thrift:"io,1" json:"io,omitempty"`
}

func NewTHBaseServiceGetScannerResultsResult() *THBaseServiceGetScannerResultsResult {
	return &THBaseServiceGetScannerResultsResult{}
}

var THBaseServiceGetScannerResultsResult_Success_DEFAULT []*TResult_

func (p *THBaseServiceGetScannerResultsResult) GetSuccess() []*TResult_ {
	return p.Success
}

var THBaseServiceGetScannerResultsResult_Io_DEFAULT *TIOError

func (p *THBaseServiceGetScannerResultsResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceGetScannerResultsResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceGetScannerResultsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceGetScannerResultsResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceGetScannerResultsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceGetScannerResultsResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*TResult_, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem132 := &TResult_{}
		if err := _elem132.Read(iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem132), err)
		}
		p.Success = append(p.Success, _elem132)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *THBaseServiceGetScannerResultsResult) readField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceGetScannerResultsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getScannerResults_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceGetScannerResultsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceGetScannerResultsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceGetScannerResultsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceGetScannerResultsResult(%+v)", *p)
}

// Attributes:
//  - Table
//  - Row
//  - Reload
type THBaseServiceGetRegionLocationArgs struct {
	Table  []byte `thrift:"table,1,required" json:"table"`
	Row    []byte `thrift:"row,2,required" json:"row"`
	Reload bool   `thrift:"reload,3" json:"reload"`
}

func NewTHBaseServiceGetRegionLocationArgs() *THBaseServiceGetRegionLocationArgs {
	return &THBaseServiceGetRegionLocationArgs{}
}

func (p *THBaseServiceGetRegionLocationArgs) GetTable() []byte {
	return p.Table
}

func (p *THBaseServiceGetRegionLocationArgs) GetRow() []byte {
	return p.Row
}

func (p *THBaseServiceGetRegionLocationArgs) GetReload() bool {
	return p.Reload
}
func (p *THBaseServiceGetRegionLocationArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTable bool = false
	var issetRow bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetTable = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetRow = true
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTable {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"))
	}
	if !issetRow {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Row is not set"))
	}
	return nil
}

func (p *THBaseServiceGetRegionLocationArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *THBaseServiceGetRegionLocationArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Row = v
	}
	return nil
}

func (p *THBaseServiceGetRegionLocationArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.Reload = v
	}
	return nil
}

func (p *THBaseServiceGetRegionLocationArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRegionLocation_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceGetRegionLocationArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err)
	}
	if err := oprot.WriteBinary(p.Table); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.table (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err)
	}
	return err
}

func (p *THBaseServiceGetRegionLocationArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("row", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:row: ", p), err)
	}
	if err := oprot.WriteBinary(p.Row); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.row (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:row: ", p), err)
	}
	return err
}

func (p *THBaseServiceGetRegionLocationArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("reload", thrift.BOOL, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:reload: ", p), err)
	}
	if err := oprot.WriteBool(bool(p.Reload)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.reload (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:reload: ", p), err)
	}
	return err
}

func (p *THBaseServiceGetRegionLocationArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceGetRegionLocationArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceGetRegionLocationResult struct {
	Success *THRegionLocation `thrift:"success,0" json:"success,omitempty"`
	Io      *TIOError         `thrift:"io,1" json:"io,omitempty"`
}

func NewTHBaseServiceGetRegionLocationResult() *THBaseServiceGetRegionLocationResult {
	return &THBaseServiceGetRegionLocationResult{}
}

var THBaseServiceGetRegionLocationResult_Success_DEFAULT *THRegionLocation

func (p *THBaseServiceGetRegionLocationResult) GetSuccess() *THRegionLocation {
	if !p.IsSetSuccess() {
		return THBaseServiceGetRegionLocationResult_Success_DEFAULT
	}
	return p.Success
}

var THBaseServiceGetRegionLocationResult_Io_DEFAULT *TIOError

func (p *THBaseServiceGetRegionLocationResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceGetRegionLocationResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceGetRegionLocationResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceGetRegionLocationResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceGetRegionLocationResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceGetRegionLocationResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &THRegionLocation{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *THBaseServiceGetRegionLocationResult) readField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceGetRegionLocationResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRegionLocation_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceGetRegionLocationResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceGetRegionLocationResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceGetRegionLocationResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceGetRegionLocationResult(%+v)", *p)
}

// Attributes:
//  - Table
type THBaseServiceGetAllRegionLocationsArgs struct {
	Table []byte `thrift:"table,1,required" json:"table"`
}

func NewTHBaseServiceGetAllRegionLocationsArgs() *THBaseServiceGetAllRegionLocationsArgs {
	return &THBaseServiceGetAllRegionLocationsArgs{}
}

func (p *THBaseServiceGetAllRegionLocationsArgs) GetTable() []byte {
	return p.Table
}
func (p *THBaseServiceGetAllRegionLocationsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTable bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetTable = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTable {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"))
	}
	return nil
}

func (p *THBaseServiceGetAllRegionLocationsArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *THBaseServiceGetAllRegionLocationsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getAllRegionLocations_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceGetAllRegionLocationsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err)
	}
	if err := oprot.WriteBinary(p.Table); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.table (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err)
	}
	return err
}

func (p *THBaseServiceGetAllRegionLocationsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceGetAllRegionLocationsArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceGetAllRegionLocationsResult struct {
	Success []*THRegionLocation `thrift:"success,0" json:"success,omitempty"`
	Io      *TIOError           `thrift:"io,1" json:"io,omitempty"`
}

func NewTHBaseServiceGetAllRegionLocationsResult() *THBaseServiceGetAllRegionLocationsResult {
	return &THBaseServiceGetAllRegionLocationsResult{}
}

var THBaseServiceGetAllRegionLocationsResult_Success_DEFAULT []*THRegionLocation

func (p *THBaseServiceGetAllRegionLocationsResult) GetSuccess() []*THRegionLocation {
	return p.Success
}

var THBaseServiceGetAllRegionLocationsResult_Io_DEFAULT *TIOError

func (p *THBaseServiceGetAllRegionLocationsResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceGetAllRegionLocationsResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceGetAllRegionLocationsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceGetAllRegionLocationsResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceGetAllRegionLocationsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceGetAllRegionLocationsResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*THRegionLocation, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem133 := &THRegionLocation{}
		if err := _elem133.Read(iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem133), err)
		}
		p.Success = append(p.Success, _elem133)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *THBaseServiceGetAllRegionLocationsResult) readField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceGetAllRegionLocationsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getAllRegionLocations_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceGetAllRegionLocationsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceGetAllRegionLocationsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceGetAllRegionLocationsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceGetAllRegionLocationsResult(%+v)", *p)
}

// Attributes:
//  - Table: to check in and delete from
//  - Row: row to check
//  - Family: column family to check
//  - Qualifier: column qualifier to check
//  - CompareOp: comparison to make on the value
//  - Value: the expected value to be compared against, if not provided the
// check is for the non-existence of the column in question
//  - RowMutations: row mutations to execute if the value matches
type THBaseServiceCheckAndMutateArgs struct {
	Table        []byte         `thrift:"table,1,required" json:"table"`
	Row          []byte         `thrift:"row,2,required" json:"row"`
	Family       []byte         `thrift:"family,3,required" json:"family"`
	Qualifier    []byte         `thrift:"qualifier,4,required" json:"qualifier"`
	CompareOp    TCompareOp     `thrift:"compareOp,5,required" json:"compareOp"`
	Value        []byte         `thrift:"value,6" json:"value"`
	RowMutations *TRowMutations `thrift:"rowMutations,7,required" json:"rowMutations"`
}

func NewTHBaseServiceCheckAndMutateArgs() *THBaseServiceCheckAndMutateArgs {
	return &THBaseServiceCheckAndMutateArgs{}
}

func (p *THBaseServiceCheckAndMutateArgs) GetTable() []byte {
	return p.Table
}

func (p *THBaseServiceCheckAndMutateArgs) GetRow() []byte {
	return p.Row
}

func (p *THBaseServiceCheckAndMutateArgs) GetFamily() []byte {
	return p.Family
}

func (p *THBaseServiceCheckAndMutateArgs) GetQualifier() []byte {
	return p.Qualifier
}

func (p *THBaseServiceCheckAndMutateArgs) GetCompareOp() TCompareOp {
	return p.CompareOp
}

func (p *THBaseServiceCheckAndMutateArgs) GetValue() []byte {
	return p.Value
}

var THBaseServiceCheckAndMutateArgs_RowMutations_DEFAULT *TRowMutations

func (p *THBaseServiceCheckAndMutateArgs) GetRowMutations() *TRowMutations {
	if !p.IsSetRowMutations() {
		return THBaseServiceCheckAndMutateArgs_RowMutations_DEFAULT
	}
	return p.RowMutations
}
func (p *THBaseServiceCheckAndMutateArgs) IsSetRowMutations() bool {
	return p.RowMutations != nil
}

func (p *THBaseServiceCheckAndMutateArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTable bool = false
	var issetRow bool = false
	var issetFamily bool = false
	var issetQualifier bool = false
	var issetCompareOp bool = false
	var issetRowMutations bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetTable = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetRow = true
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
			issetFamily = true
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
			issetQualifier = true
		case 5:
			if err := p.readField5(iprot); err != nil {
				return err
			}
			issetCompareOp = true
		case 6:
			if err := p.readField6(iprot); err != nil {
				return err
			}
		case 7:
			if err := p.readField7(iprot); err != nil {
				return err
			}
			issetRowMutations = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTable {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"))
	}
	if !issetRow {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Row is not set"))
	}
	if !issetFamily {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Family is not set"))
	}
	if !issetQualifier {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Qualifier is not set"))
	}
	if !issetCompareOp {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field CompareOp is not set"))
	}
	if !issetRowMutations {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field RowMutations is not set"))
	}
	return nil
}

func (p *THBaseServiceCheckAndMutateArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *THBaseServiceCheckAndMutateArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Row = v
	}
	return nil
}

func (p *THBaseServiceCheckAndMutateArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.Family = v
	}
	return nil
}

func (p *THBaseServiceCheckAndMutateArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.Qualifier = v
	}
	return nil
}

func (p *THBaseServiceCheckAndMutateArgs) readField5(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 5: ", err)
	} else {
		temp := TCompareOp(v)
		p.CompareOp = temp
	}
	return nil
}

func (p *THBaseServiceCheckAndMutateArgs) readField6(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 6: ", err)
	} else {
		p.Value = v
	}
	return nil
}

func (p *THBaseServiceCheckAndMutateArgs) readField7(iprot thrift.TProtocol) error {
	p.RowMutations = &TRowMutations{}
	if err := p.RowMutations.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.RowMutations), err)
	}
	return nil
}

func (p *THBaseServiceCheckAndMutateArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("checkAndMutate_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := p.writeField6(oprot); err != nil {
		return err
	}
	if err := p.writeField7(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceCheckAndMutateArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err)
	}
	if err := oprot.WriteBinary(p.Table); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.table (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err)
	}
	return err
}

func (p *THBaseServiceCheckAndMutateArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("row", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:row: ", p), err)
	}
	if err := oprot.WriteBinary(p.Row); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.row (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:row: ", p), err)
	}
	return err
}

func (p *THBaseServiceCheckAndMutateArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("family", thrift.STRING, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:family: ", p), err)
	}
	if err := oprot.WriteBinary(p.Family); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.family (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:family: ", p), err)
	}
	return err
}

func (p *THBaseServiceCheckAndMutateArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("qualifier", thrift.STRING, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:qualifier: ", p), err)
	}
	if err := oprot.WriteBinary(p.Qualifier); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.qualifier (4) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:qualifier: ", p), err)
	}
	return err
}

func (p *THBaseServiceCheckAndMutateArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("compareOp", thrift.I32, 5); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:compareOp: ", p), err)
	}
	if err := oprot.WriteI32(int32(p.CompareOp)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.compareOp (5) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 5:compareOp: ", p), err)
	}
	return err
}

func (p *THBaseServiceCheckAndMutateArgs) writeField6(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("value", thrift.STRING, 6); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:value: ", p), err)
	}
	if err := oprot.WriteBinary(p.Value); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.value (6) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 6:value: ", p), err)
	}
	return err
}

func (p *THBaseServiceCheckAndMutateArgs) writeField7(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("rowMutations", thrift.STRUCT, 7); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:rowMutations: ", p), err)
	}
	if err := p.RowMutations.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.RowMutations), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 7:rowMutations: ", p), err)
	}
	return err
}

func (p *THBaseServiceCheckAndMutateArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceCheckAndMutateArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceCheckAndMutateResult struct {
	Success *bool     `thrift:"success,0" json:"success,omitempty"`
	Io      *TIOError `thrift:"io,1" json:"io,omitempty"`
}

func NewTHBaseServiceCheckAndMutateResult() *THBaseServiceCheckAndMutateResult {
	return &THBaseServiceCheckAndMutateResult{}
}

var THBaseServiceCheckAndMutateResult_Success_DEFAULT bool

func (p *THBaseServiceCheckAndMutateResult) GetSuccess() bool {
	if !p.IsSetSuccess() {
		return THBaseServiceCheckAndMutateResult_Success_DEFAULT
	}
	return *p.Success
}

var THBaseServiceCheckAndMutateResult_Io_DEFAULT *TIOError

func (p *THBaseServiceCheckAndMutateResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceCheckAndMutateResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceCheckAndMutateResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceCheckAndMutateResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceCheckAndMutateResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceCheckAndMutateResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return thrift.PrependError("error reading field 0: ", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *THBaseServiceCheckAndMutateResult) readField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceCheckAndMutateResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("checkAndMutate_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceCheckAndMutateResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.BOOL, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteBool(bool(*p.Success)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceCheckAndMutateResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceCheckAndMutateResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceCheckAndMutateResult(%+v)", *p)
}

// Attributes:
//  - Table: the tablename of the table to get tableDescriptor
type THBaseServiceGetTableDescriptorArgs struct {
	Table *TTableName `thrift:"table,1,required" json:"table"`
}

func NewTHBaseServiceGetTableDescriptorArgs() *THBaseServiceGetTableDescriptorArgs {
	return &THBaseServiceGetTableDescriptorArgs{}
}

var THBaseServiceGetTableDescriptorArgs_Table_DEFAULT *TTableName

func (p *THBaseServiceGetTableDescriptorArgs) GetTable() *TTableName {
	if !p.IsSetTable() {
		return THBaseServiceGetTableDescriptorArgs_Table_DEFAULT
	}
	return p.Table
}
func (p *THBaseServiceGetTableDescriptorArgs) IsSetTable() bool {
	return p.Table != nil
}

func (p *THBaseServiceGetTableDescriptorArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTable bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetTable = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTable {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Table is not set"))
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorArgs) readField1(iprot thrift.TProtocol) error {
	p.Table = &TTableName{}
	if err := p.Table.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Table), err)
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTableDescriptor_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:table: ", p), err)
	}
	if err := p.Table.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Table), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:table: ", p), err)
	}
	return err
}

func (p *THBaseServiceGetTableDescriptorArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceGetTableDescriptorArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceGetTableDescriptorResult struct {
	Success *TTableDescriptor `thrift:"success,0" json:"success,omitempty"`
	Io      *TIOError         `thrift:"io,1" json:"io,omitempty"`
}

func NewTHBaseServiceGetTableDescriptorResult() *THBaseServiceGetTableDescriptorResult {
	return &THBaseServiceGetTableDescriptorResult{}
}

var THBaseServiceGetTableDescriptorResult_Success_DEFAULT *TTableDescriptor

func (p *THBaseServiceGetTableDescriptorResult) GetSuccess() *TTableDescriptor {
	if !p.IsSetSuccess() {
		return THBaseServiceGetTableDescriptorResult_Success_DEFAULT
	}
	return p.Success
}

var THBaseServiceGetTableDescriptorResult_Io_DEFAULT *TIOError

func (p *THBaseServiceGetTableDescriptorResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceGetTableDescriptorResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceGetTableDescriptorResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceGetTableDescriptorResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceGetTableDescriptorResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &TTableDescriptor{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorResult) readField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTableDescriptor_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceGetTableDescriptorResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceGetTableDescriptorResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceGetTableDescriptorResult(%+v)", *p)
}

// Attributes:
//  - Tables: the tablename list of the tables to get tableDescriptor
type THBaseServiceGetTableDescriptorsArgs struct {
	Tables []*TTableName `thrift:"tables,1,required" json:"tables"`
}

func NewTHBaseServiceGetTableDescriptorsArgs() *THBaseServiceGetTableDescriptorsArgs {
	return &THBaseServiceGetTableDescriptorsArgs{}
}

func (p *THBaseServiceGetTableDescriptorsArgs) GetTables() []*TTableName {
	return p.Tables
}
func (p *THBaseServiceGetTableDescriptorsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTables bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetTables = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTables {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Tables is not set"))
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorsArgs) readField1(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*TTableName, 0, size)
	p.Tables = tSlice
	for i := 0; i < size; i++ {
		_elem134 := &TTableName{}
		if err := _elem134.Read(iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem134), err)
		}
		p.Tables = append(p.Tables, _elem134)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTableDescriptors_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tables", thrift.LIST, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tables: ", p), err)
	}
	if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Tables)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Tables {
		if err := v.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tables: ", p), err)
	}
	return err
}

func (p *THBaseServiceGetTableDescriptorsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceGetTableDescriptorsArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceGetTableDescriptorsResult struct {
	Success []*TTableDescriptor `thrift:"success,0" json:"success,omitempty"`
	Io      *TIOError           `thrift:"io,1" json:"io,omitempty"`
}

func NewTHBaseServiceGetTableDescriptorsResult() *THBaseServiceGetTableDescriptorsResult {
	return &THBaseServiceGetTableDescriptorsResult{}
}

var THBaseServiceGetTableDescriptorsResult_Success_DEFAULT []*TTableDescriptor

func (p *THBaseServiceGetTableDescriptorsResult) GetSuccess() []*TTableDescriptor {
	return p.Success
}

var THBaseServiceGetTableDescriptorsResult_Io_DEFAULT *TIOError

func (p *THBaseServiceGetTableDescriptorsResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceGetTableDescriptorsResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceGetTableDescriptorsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceGetTableDescriptorsResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceGetTableDescriptorsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorsResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*TTableDescriptor, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem135 := &TTableDescriptor{}
		if err := _elem135.Read(iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem135), err)
		}
		p.Success = append(p.Success, _elem135)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorsResult) readField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTableDescriptors_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceGetTableDescriptorsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceGetTableDescriptorsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceGetTableDescriptorsResult(%+v)", *p)
}

// Attributes:
//  - TableName: the tablename of the tables to check
type THBaseServiceTableExistsArgs struct {
	TableName *TTableName `thrift:"tableName,1" json:"tableName"`
}

func NewTHBaseServiceTableExistsArgs() *THBaseServiceTableExistsArgs {
	return &THBaseServiceTableExistsArgs{}
}

var THBaseServiceTableExistsArgs_TableName_DEFAULT *TTableName

func (p *THBaseServiceTableExistsArgs) GetTableName() *TTableName {
	if !p.IsSetTableName() {
		return THBaseServiceTableExistsArgs_TableName_DEFAULT
	}
	return p.TableName
}
func (p *THBaseServiceTableExistsArgs) IsSetTableName() bool {
	return p.TableName != nil
}

func (p *THBaseServiceTableExistsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceTableExistsArgs) readField1(iprot thrift.TProtocol) error {
	p.TableName = &TTableName{}
	if err := p.TableName.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TableName), err)
	}
	return nil
}

func (p *THBaseServiceTableExistsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("tableExists_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceTableExistsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tableName: ", p), err)
	}
	if err := p.TableName.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TableName), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tableName: ", p), err)
	}
	return err
}

func (p *THBaseServiceTableExistsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceTableExistsArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceTableExistsResult struct {
	Success *bool     `thrift:"success,0" json:"success,omitempty"`
	Io      *TIOError `thrift:"io,1" json:"io,omitempty"`
}

func NewTHBaseServiceTableExistsResult() *THBaseServiceTableExistsResult {
	return &THBaseServiceTableExistsResult{}
}

var THBaseServiceTableExistsResult_Success_DEFAULT bool

func (p *THBaseServiceTableExistsResult) GetSuccess() bool {
	if !p.IsSetSuccess() {
		return THBaseServiceTableExistsResult_Success_DEFAULT
	}
	return *p.Success
}

var THBaseServiceTableExistsResult_Io_DEFAULT *TIOError

func (p *THBaseServiceTableExistsResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceTableExistsResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceTableExistsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceTableExistsResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceTableExistsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceTableExistsResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return thrift.PrependError("error reading field 0: ", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *THBaseServiceTableExistsResult) readField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceTableExistsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("tableExists_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceTableExistsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.BOOL, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteBool(bool(*p.Success)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceTableExistsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceTableExistsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceTableExistsResult(%+v)", *p)
}

// Attributes:
//  - Regex: The regular expression to match against
//  - IncludeSysTables: set to false if match only against userspace tables
type THBaseServiceGetTableDescriptorsByPatternArgs struct {
	Regex            string `thrift:"regex,1" json:"regex"`
	IncludeSysTables bool   `thrift:"includeSysTables,2,required" json:"includeSysTables"`
}

func NewTHBaseServiceGetTableDescriptorsByPatternArgs() *THBaseServiceGetTableDescriptorsByPatternArgs {
	return &THBaseServiceGetTableDescriptorsByPatternArgs{}
}

func (p *THBaseServiceGetTableDescriptorsByPatternArgs) GetRegex() string {
	return p.Regex
}

func (p *THBaseServiceGetTableDescriptorsByPatternArgs) GetIncludeSysTables() bool {
	return p.IncludeSysTables
}
func (p *THBaseServiceGetTableDescriptorsByPatternArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetIncludeSysTables bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetIncludeSysTables = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetIncludeSysTables {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field IncludeSysTables is not set"))
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorsByPatternArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Regex = v
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorsByPatternArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.IncludeSysTables = v
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorsByPatternArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTableDescriptorsByPattern_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorsByPatternArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("regex", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:regex: ", p), err)
	}
	if err := oprot.WriteString(string(p.Regex)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.regex (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:regex: ", p), err)
	}
	return err
}

func (p *THBaseServiceGetTableDescriptorsByPatternArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("includeSysTables", thrift.BOOL, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:includeSysTables: ", p), err)
	}
	if err := oprot.WriteBool(bool(p.IncludeSysTables)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.includeSysTables (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:includeSysTables: ", p), err)
	}
	return err
}

func (p *THBaseServiceGetTableDescriptorsByPatternArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceGetTableDescriptorsByPatternArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceGetTableDescriptorsByPatternResult struct {
	Success []*TTableDescriptor `thrift:"success,0" json:"success,omitempty"`
	Io      *TIOError           `thrift:"io,1" json:"io,omitempty"`
}

func NewTHBaseServiceGetTableDescriptorsByPatternResult() *THBaseServiceGetTableDescriptorsByPatternResult {
	return &THBaseServiceGetTableDescriptorsByPatternResult{}
}

var THBaseServiceGetTableDescriptorsByPatternResult_Success_DEFAULT []*TTableDescriptor

func (p *THBaseServiceGetTableDescriptorsByPatternResult) GetSuccess() []*TTableDescriptor {
	return p.Success
}

var THBaseServiceGetTableDescriptorsByPatternResult_Io_DEFAULT *TIOError

func (p *THBaseServiceGetTableDescriptorsByPatternResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceGetTableDescriptorsByPatternResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceGetTableDescriptorsByPatternResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceGetTableDescriptorsByPatternResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceGetTableDescriptorsByPatternResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorsByPatternResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*TTableDescriptor, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem136 := &TTableDescriptor{}
		if err := _elem136.Read(iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem136), err)
		}
		p.Success = append(p.Success, _elem136)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorsByPatternResult) readField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorsByPatternResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTableDescriptorsByPattern_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorsByPatternResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceGetTableDescriptorsByPatternResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceGetTableDescriptorsByPatternResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceGetTableDescriptorsByPatternResult(%+v)", *p)
}

// Attributes:
//  - Name: The namesapce's name
type THBaseServiceGetTableDescriptorsByNamespaceArgs struct {
	Name string `thrift:"name,1,required" json:"name"`
}

func NewTHBaseServiceGetTableDescriptorsByNamespaceArgs() *THBaseServiceGetTableDescriptorsByNamespaceArgs {
	return &THBaseServiceGetTableDescriptorsByNamespaceArgs{}
}

func (p *THBaseServiceGetTableDescriptorsByNamespaceArgs) GetName() string {
	return p.Name
}
func (p *THBaseServiceGetTableDescriptorsByNamespaceArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetName bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetName = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetName {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Name is not set"))
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorsByNamespaceArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Name = v
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorsByNamespaceArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTableDescriptorsByNamespace_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorsByNamespaceArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err)
	}
	if err := oprot.WriteString(string(p.Name)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.name (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err)
	}
	return err
}

func (p *THBaseServiceGetTableDescriptorsByNamespaceArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceGetTableDescriptorsByNamespaceArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceGetTableDescriptorsByNamespaceResult struct {
	Success []*TTableDescriptor `thrift:"success,0" json:"success,omitempty"`
	Io      *TIOError           `thrift:"io,1" json:"io,omitempty"`
}

func NewTHBaseServiceGetTableDescriptorsByNamespaceResult() *THBaseServiceGetTableDescriptorsByNamespaceResult {
	return &THBaseServiceGetTableDescriptorsByNamespaceResult{}
}

var THBaseServiceGetTableDescriptorsByNamespaceResult_Success_DEFAULT []*TTableDescriptor

func (p *THBaseServiceGetTableDescriptorsByNamespaceResult) GetSuccess() []*TTableDescriptor {
	return p.Success
}

var THBaseServiceGetTableDescriptorsByNamespaceResult_Io_DEFAULT *TIOError

func (p *THBaseServiceGetTableDescriptorsByNamespaceResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceGetTableDescriptorsByNamespaceResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceGetTableDescriptorsByNamespaceResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceGetTableDescriptorsByNamespaceResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceGetTableDescriptorsByNamespaceResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorsByNamespaceResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*TTableDescriptor, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem137 := &TTableDescriptor{}
		if err := _elem137.Read(iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem137), err)
		}
		p.Success = append(p.Success, _elem137)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorsByNamespaceResult) readField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorsByNamespaceResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTableDescriptorsByNamespace_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceGetTableDescriptorsByNamespaceResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceGetTableDescriptorsByNamespaceResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceGetTableDescriptorsByNamespaceResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceGetTableDescriptorsByNamespaceResult(%+v)", *p)
}

// Attributes:
//  - Regex: The regular expression to match against
//  - IncludeSysTables: set to false if match only against userspace tables
type THBaseServiceGetTableNamesByPatternArgs struct {
	Regex            string `thrift:"regex,1" json:"regex"`
	IncludeSysTables bool   `thrift:"includeSysTables,2,required" json:"includeSysTables"`
}

func NewTHBaseServiceGetTableNamesByPatternArgs() *THBaseServiceGetTableNamesByPatternArgs {
	return &THBaseServiceGetTableNamesByPatternArgs{}
}

func (p *THBaseServiceGetTableNamesByPatternArgs) GetRegex() string {
	return p.Regex
}

func (p *THBaseServiceGetTableNamesByPatternArgs) GetIncludeSysTables() bool {
	return p.IncludeSysTables
}
func (p *THBaseServiceGetTableNamesByPatternArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetIncludeSysTables bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetIncludeSysTables = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetIncludeSysTables {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field IncludeSysTables is not set"))
	}
	return nil
}

func (p *THBaseServiceGetTableNamesByPatternArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Regex = v
	}
	return nil
}

func (p *THBaseServiceGetTableNamesByPatternArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.IncludeSysTables = v
	}
	return nil
}

func (p *THBaseServiceGetTableNamesByPatternArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTableNamesByPattern_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceGetTableNamesByPatternArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("regex", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:regex: ", p), err)
	}
	if err := oprot.WriteString(string(p.Regex)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.regex (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:regex: ", p), err)
	}
	return err
}

func (p *THBaseServiceGetTableNamesByPatternArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("includeSysTables", thrift.BOOL, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:includeSysTables: ", p), err)
	}
	if err := oprot.WriteBool(bool(p.IncludeSysTables)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.includeSysTables (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:includeSysTables: ", p), err)
	}
	return err
}

func (p *THBaseServiceGetTableNamesByPatternArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceGetTableNamesByPatternArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceGetTableNamesByPatternResult struct {
	Success []*TTableName `thrift:"success,0" json:"success,omitempty"`
	Io      *TIOError     `thrift:"io,1" json:"io,omitempty"`
}

func NewTHBaseServiceGetTableNamesByPatternResult() *THBaseServiceGetTableNamesByPatternResult {
	return &THBaseServiceGetTableNamesByPatternResult{}
}

var THBaseServiceGetTableNamesByPatternResult_Success_DEFAULT []*TTableName

func (p *THBaseServiceGetTableNamesByPatternResult) GetSuccess() []*TTableName {
	return p.Success
}

var THBaseServiceGetTableNamesByPatternResult_Io_DEFAULT *TIOError

func (p *THBaseServiceGetTableNamesByPatternResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceGetTableNamesByPatternResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceGetTableNamesByPatternResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceGetTableNamesByPatternResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceGetTableNamesByPatternResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceGetTableNamesByPatternResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*TTableName, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem138 := &TTableName{}
		if err := _elem138.Read(iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem138), err)
		}
		p.Success = append(p.Success, _elem138)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *THBaseServiceGetTableNamesByPatternResult) readField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceGetTableNamesByPatternResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTableNamesByPattern_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceGetTableNamesByPatternResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceGetTableNamesByPatternResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceGetTableNamesByPatternResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceGetTableNamesByPatternResult(%+v)", *p)
}

// Attributes:
//  - Name: The namesapce's name
type THBaseServiceGetTableNamesByNamespaceArgs struct {
	Name string `thrift:"name,1,required" json:"name"`
}

func NewTHBaseServiceGetTableNamesByNamespaceArgs() *THBaseServiceGetTableNamesByNamespaceArgs {
	return &THBaseServiceGetTableNamesByNamespaceArgs{}
}

func (p *THBaseServiceGetTableNamesByNamespaceArgs) GetName() string {
	return p.Name
}
func (p *THBaseServiceGetTableNamesByNamespaceArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetName bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetName = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetName {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Name is not set"))
	}
	return nil
}

func (p *THBaseServiceGetTableNamesByNamespaceArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Name = v
	}
	return nil
}

func (p *THBaseServiceGetTableNamesByNamespaceArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTableNamesByNamespace_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceGetTableNamesByNamespaceArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err)
	}
	if err := oprot.WriteString(string(p.Name)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.name (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err)
	}
	return err
}

func (p *THBaseServiceGetTableNamesByNamespaceArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceGetTableNamesByNamespaceArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceGetTableNamesByNamespaceResult struct {
	Success []*TTableName `thrift:"success,0" json:"success,omitempty"`
	Io      *TIOError     `thrift:"io,1" json:"io,omitempty"`
}

func NewTHBaseServiceGetTableNamesByNamespaceResult() *THBaseServiceGetTableNamesByNamespaceResult {
	return &THBaseServiceGetTableNamesByNamespaceResult{}
}

var THBaseServiceGetTableNamesByNamespaceResult_Success_DEFAULT []*TTableName

func (p *THBaseServiceGetTableNamesByNamespaceResult) GetSuccess() []*TTableName {
	return p.Success
}

var THBaseServiceGetTableNamesByNamespaceResult_Io_DEFAULT *TIOError

func (p *THBaseServiceGetTableNamesByNamespaceResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceGetTableNamesByNamespaceResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceGetTableNamesByNamespaceResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceGetTableNamesByNamespaceResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceGetTableNamesByNamespaceResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceGetTableNamesByNamespaceResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*TTableName, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem139 := &TTableName{}
		if err := _elem139.Read(iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem139), err)
		}
		p.Success = append(p.Success, _elem139)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *THBaseServiceGetTableNamesByNamespaceResult) readField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceGetTableNamesByNamespaceResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTableNamesByNamespace_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceGetTableNamesByNamespaceResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceGetTableNamesByNamespaceResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceGetTableNamesByNamespaceResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceGetTableNamesByNamespaceResult(%+v)", *p)
}

// Attributes:
//  - Desc: table descriptor for table
//  - SplitKeys: rray of split keys for the initial regions of the table
type THBaseServiceCreateTableArgs struct {
	Desc      *TTableDescriptor `thrift:"desc,1,required" json:"desc"`
	SplitKeys [][]byte          `thrift:"splitKeys,2" json:"splitKeys"`
}

func NewTHBaseServiceCreateTableArgs() *THBaseServiceCreateTableArgs {
	return &THBaseServiceCreateTableArgs{}
}

var THBaseServiceCreateTableArgs_Desc_DEFAULT *TTableDescriptor

func (p *THBaseServiceCreateTableArgs) GetDesc() *TTableDescriptor {
	if !p.IsSetDesc() {
		return THBaseServiceCreateTableArgs_Desc_DEFAULT
	}
	return p.Desc
}

func (p *THBaseServiceCreateTableArgs) GetSplitKeys() [][]byte {
	return p.SplitKeys
}
func (p *THBaseServiceCreateTableArgs) IsSetDesc() bool {
	return p.Desc != nil
}

func (p *THBaseServiceCreateTableArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetDesc bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetDesc = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetDesc {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Desc is not set"))
	}
	return nil
}

func (p *THBaseServiceCreateTableArgs) readField1(iprot thrift.TProtocol) error {
	p.Desc = &TTableDescriptor{}
	if err := p.Desc.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Desc), err)
	}
	return nil
}

func (p *THBaseServiceCreateTableArgs) readField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([][]byte, 0, size)
	p.SplitKeys = tSlice
	for i := 0; i < size; i++ {
		var _elem140 []byte
		if v, err := iprot.ReadBinary(); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem140 = v
		}
		p.SplitKeys = append(p.SplitKeys, _elem140)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *THBaseServiceCreateTableArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("createTable_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceCreateTableArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("desc", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:desc: ", p), err)
	}
	if err := p.Desc.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Desc), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:desc: ", p), err)
	}
	return err
}

func (p *THBaseServiceCreateTableArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("splitKeys", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:splitKeys: ", p), err)
	}
	if err := oprot.WriteListBegin(thrift.STRING, len(p.SplitKeys)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.SplitKeys {
		if err := oprot.WriteBinary(v); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:splitKeys: ", p), err)
	}
	return err
}

func (p *THBaseServiceCreateTableArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceCreateTableArgs(%+v)", *p)
}

// Attributes:
//  - Io
type THBaseServiceCreateTableResult struct {
	Io *TIOError `thrift:"io,1" json:"io,omitempty"`
}

func NewTHBaseServiceCreateTableResult() *THBaseServiceCreateTableResult {
	return &THBaseServiceCreateTableResult{}
}

var THBaseServiceCreateTableResult_Io_DEFAULT *TIOError

func (p *THBaseServiceCreateTableResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceCreateTableResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceCreateTableResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceCreateTableResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceCreateTableResult) readField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceCreateTableResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("createTable_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceCreateTableResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceCreateTableResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceCreateTableResult(%+v)", *p)
}

// Attributes:
//  - TableName: the tablename to delete
type THBaseServiceDeleteTableArgs struct {
	TableName *TTableName `thrift:"tableName,1,required" json:"tableName"`
}

func NewTHBaseServiceDeleteTableArgs() *THBaseServiceDeleteTableArgs {
	return &THBaseServiceDeleteTableArgs{}
}

var THBaseServiceDeleteTableArgs_TableName_DEFAULT *TTableName

func (p *THBaseServiceDeleteTableArgs) GetTableName() *TTableName {
	if !p.IsSetTableName() {
		return THBaseServiceDeleteTableArgs_TableName_DEFAULT
	}
	return p.TableName
}
func (p *THBaseServiceDeleteTableArgs) IsSetTableName() bool {
	return p.TableName != nil
}

func (p *THBaseServiceDeleteTableArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTableName bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetTableName = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTableName {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TableName is not set"))
	}
	return nil
}

func (p *THBaseServiceDeleteTableArgs) readField1(iprot thrift.TProtocol) error {
	p.TableName = &TTableName{}
	if err := p.TableName.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TableName), err)
	}
	return nil
}

func (p *THBaseServiceDeleteTableArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteTable_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceDeleteTableArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tableName: ", p), err)
	}
	if err := p.TableName.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TableName), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tableName: ", p), err)
	}
	return err
}

func (p *THBaseServiceDeleteTableArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceDeleteTableArgs(%+v)", *p)
}

// Attributes:
//  - Io
type THBaseServiceDeleteTableResult struct {
	Io *TIOError `thrift:"io,1" json:"io,omitempty"`
}

func NewTHBaseServiceDeleteTableResult() *THBaseServiceDeleteTableResult {
	return &THBaseServiceDeleteTableResult{}
}

var THBaseServiceDeleteTableResult_Io_DEFAULT *TIOError

func (p *THBaseServiceDeleteTableResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceDeleteTableResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceDeleteTableResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceDeleteTableResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceDeleteTableResult) readField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceDeleteTableResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteTable_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceDeleteTableResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceDeleteTableResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceDeleteTableResult(%+v)", *p)
}

// Attributes:
//  - TableName: the tablename to truncate
//  - PreserveSplits: whether to  preserve previous splits
type THBaseServiceTruncateTableArgs struct {
	TableName      *TTableName `thrift:"tableName,1,required" json:"tableName"`
	PreserveSplits bool        `thrift:"preserveSplits,2,required" json:"preserveSplits"`
}

func NewTHBaseServiceTruncateTableArgs() *THBaseServiceTruncateTableArgs {
	return &THBaseServiceTruncateTableArgs{}
}

var THBaseServiceTruncateTableArgs_TableName_DEFAULT *TTableName

func (p *THBaseServiceTruncateTableArgs) GetTableName() *TTableName {
	if !p.IsSetTableName() {
		return THBaseServiceTruncateTableArgs_TableName_DEFAULT
	}
	return p.TableName
}

func (p *THBaseServiceTruncateTableArgs) GetPreserveSplits() bool {
	return p.PreserveSplits
}
func (p *THBaseServiceTruncateTableArgs) IsSetTableName() bool {
	return p.TableName != nil
}

func (p *THBaseServiceTruncateTableArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTableName bool = false
	var issetPreserveSplits bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetTableName = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetPreserveSplits = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTableName {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TableName is not set"))
	}
	if !issetPreserveSplits {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field PreserveSplits is not set"))
	}
	return nil
}

func (p *THBaseServiceTruncateTableArgs) readField1(iprot thrift.TProtocol) error {
	p.TableName = &TTableName{}
	if err := p.TableName.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TableName), err)
	}
	return nil
}

func (p *THBaseServiceTruncateTableArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.PreserveSplits = v
	}
	return nil
}

func (p *THBaseServiceTruncateTableArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("truncateTable_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceTruncateTableArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tableName: ", p), err)
	}
	if err := p.TableName.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TableName), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tableName: ", p), err)
	}
	return err
}

func (p *THBaseServiceTruncateTableArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("preserveSplits", thrift.BOOL, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:preserveSplits: ", p), err)
	}
	if err := oprot.WriteBool(bool(p.PreserveSplits)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.preserveSplits (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:preserveSplits: ", p), err)
	}
	return err
}

func (p *THBaseServiceTruncateTableArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceTruncateTableArgs(%+v)", *p)
}

// Attributes:
//  - Io
type THBaseServiceTruncateTableResult struct {
	Io *TIOError `thrift:"io,1" json:"io,omitempty"`
}

func NewTHBaseServiceTruncateTableResult() *THBaseServiceTruncateTableResult {
	return &THBaseServiceTruncateTableResult{}
}

var THBaseServiceTruncateTableResult_Io_DEFAULT *TIOError

func (p *THBaseServiceTruncateTableResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceTruncateTableResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceTruncateTableResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceTruncateTableResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceTruncateTableResult) readField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceTruncateTableResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("truncateTable_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceTruncateTableResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceTruncateTableResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceTruncateTableResult(%+v)", *p)
}

// Attributes:
//  - TableName: the tablename to enable
type THBaseServiceEnableTableArgs struct {
	TableName *TTableName `thrift:"tableName,1,required" json:"tableName"`
}

func NewTHBaseServiceEnableTableArgs() *THBaseServiceEnableTableArgs {
	return &THBaseServiceEnableTableArgs{}
}

var THBaseServiceEnableTableArgs_TableName_DEFAULT *TTableName

func (p *THBaseServiceEnableTableArgs) GetTableName() *TTableName {
	if !p.IsSetTableName() {
		return THBaseServiceEnableTableArgs_TableName_DEFAULT
	}
	return p.TableName
}
func (p *THBaseServiceEnableTableArgs) IsSetTableName() bool {
	return p.TableName != nil
}

func (p *THBaseServiceEnableTableArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTableName bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetTableName = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTableName {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TableName is not set"))
	}
	return nil
}

func (p *THBaseServiceEnableTableArgs) readField1(iprot thrift.TProtocol) error {
	p.TableName = &TTableName{}
	if err := p.TableName.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TableName), err)
	}
	return nil
}

func (p *THBaseServiceEnableTableArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("enableTable_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceEnableTableArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tableName: ", p), err)
	}
	if err := p.TableName.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TableName), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tableName: ", p), err)
	}
	return err
}

func (p *THBaseServiceEnableTableArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceEnableTableArgs(%+v)", *p)
}

// Attributes:
//  - Io
type THBaseServiceEnableTableResult struct {
	Io *TIOError `thrift:"io,1" json:"io,omitempty"`
}

func NewTHBaseServiceEnableTableResult() *THBaseServiceEnableTableResult {
	return &THBaseServiceEnableTableResult{}
}

var THBaseServiceEnableTableResult_Io_DEFAULT *TIOError

func (p *THBaseServiceEnableTableResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceEnableTableResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceEnableTableResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceEnableTableResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceEnableTableResult) readField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceEnableTableResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("enableTable_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceEnableTableResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceEnableTableResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceEnableTableResult(%+v)", *p)
}

// Attributes:
//  - TableName: the tablename to disable
type THBaseServiceDisableTableArgs struct {
	TableName *TTableName `thrift:"tableName,1,required" json:"tableName"`
}

func NewTHBaseServiceDisableTableArgs() *THBaseServiceDisableTableArgs {
	return &THBaseServiceDisableTableArgs{}
}

var THBaseServiceDisableTableArgs_TableName_DEFAULT *TTableName

func (p *THBaseServiceDisableTableArgs) GetTableName() *TTableName {
	if !p.IsSetTableName() {
		return THBaseServiceDisableTableArgs_TableName_DEFAULT
	}
	return p.TableName
}
func (p *THBaseServiceDisableTableArgs) IsSetTableName() bool {
	return p.TableName != nil
}

func (p *THBaseServiceDisableTableArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTableName bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetTableName = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTableName {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TableName is not set"))
	}
	return nil
}

func (p *THBaseServiceDisableTableArgs) readField1(iprot thrift.TProtocol) error {
	p.TableName = &TTableName{}
	if err := p.TableName.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TableName), err)
	}
	return nil
}

func (p *THBaseServiceDisableTableArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("disableTable_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceDisableTableArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tableName: ", p), err)
	}
	if err := p.TableName.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TableName), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tableName: ", p), err)
	}
	return err
}

func (p *THBaseServiceDisableTableArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceDisableTableArgs(%+v)", *p)
}

// Attributes:
//  - Io
type THBaseServiceDisableTableResult struct {
	Io *TIOError `thrift:"io,1" json:"io,omitempty"`
}

func NewTHBaseServiceDisableTableResult() *THBaseServiceDisableTableResult {
	return &THBaseServiceDisableTableResult{}
}

var THBaseServiceDisableTableResult_Io_DEFAULT *TIOError

func (p *THBaseServiceDisableTableResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceDisableTableResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceDisableTableResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceDisableTableResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceDisableTableResult) readField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceDisableTableResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("disableTable_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceDisableTableResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceDisableTableResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceDisableTableResult(%+v)", *p)
}

// Attributes:
//  - TableName: the tablename to check
type THBaseServiceIsTableEnabledArgs struct {
	TableName *TTableName `thrift:"tableName,1,required" json:"tableName"`
}

func NewTHBaseServiceIsTableEnabledArgs() *THBaseServiceIsTableEnabledArgs {
	return &THBaseServiceIsTableEnabledArgs{}
}

var THBaseServiceIsTableEnabledArgs_TableName_DEFAULT *TTableName

func (p *THBaseServiceIsTableEnabledArgs) GetTableName() *TTableName {
	if !p.IsSetTableName() {
		return THBaseServiceIsTableEnabledArgs_TableName_DEFAULT
	}
	return p.TableName
}
func (p *THBaseServiceIsTableEnabledArgs) IsSetTableName() bool {
	return p.TableName != nil
}

func (p *THBaseServiceIsTableEnabledArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTableName bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetTableName = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTableName {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TableName is not set"))
	}
	return nil
}

func (p *THBaseServiceIsTableEnabledArgs) readField1(iprot thrift.TProtocol) error {
	p.TableName = &TTableName{}
	if err := p.TableName.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TableName), err)
	}
	return nil
}

func (p *THBaseServiceIsTableEnabledArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("isTableEnabled_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceIsTableEnabledArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tableName: ", p), err)
	}
	if err := p.TableName.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TableName), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tableName: ", p), err)
	}
	return err
}

func (p *THBaseServiceIsTableEnabledArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceIsTableEnabledArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceIsTableEnabledResult struct {
	Success *bool     `thrift:"success,0" json:"success,omitempty"`
	Io      *TIOError `thrift:"io,1" json:"io,omitempty"`
}

func NewTHBaseServiceIsTableEnabledResult() *THBaseServiceIsTableEnabledResult {
	return &THBaseServiceIsTableEnabledResult{}
}

var THBaseServiceIsTableEnabledResult_Success_DEFAULT bool

func (p *THBaseServiceIsTableEnabledResult) GetSuccess() bool {
	if !p.IsSetSuccess() {
		return THBaseServiceIsTableEnabledResult_Success_DEFAULT
	}
	return *p.Success
}

var THBaseServiceIsTableEnabledResult_Io_DEFAULT *TIOError

func (p *THBaseServiceIsTableEnabledResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceIsTableEnabledResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceIsTableEnabledResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceIsTableEnabledResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceIsTableEnabledResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceIsTableEnabledResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return thrift.PrependError("error reading field 0: ", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *THBaseServiceIsTableEnabledResult) readField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceIsTableEnabledResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("isTableEnabled_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceIsTableEnabledResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.BOOL, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteBool(bool(*p.Success)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceIsTableEnabledResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceIsTableEnabledResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceIsTableEnabledResult(%+v)", *p)
}

// Attributes:
//  - TableName: the tablename to check
type THBaseServiceIsTableDisabledArgs struct {
	TableName *TTableName `thrift:"tableName,1,required" json:"tableName"`
}

func NewTHBaseServiceIsTableDisabledArgs() *THBaseServiceIsTableDisabledArgs {
	return &THBaseServiceIsTableDisabledArgs{}
}

var THBaseServiceIsTableDisabledArgs_TableName_DEFAULT *TTableName

func (p *THBaseServiceIsTableDisabledArgs) GetTableName() *TTableName {
	if !p.IsSetTableName() {
		return THBaseServiceIsTableDisabledArgs_TableName_DEFAULT
	}
	return p.TableName
}
func (p *THBaseServiceIsTableDisabledArgs) IsSetTableName() bool {
	return p.TableName != nil
}

func (p *THBaseServiceIsTableDisabledArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTableName bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetTableName = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTableName {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TableName is not set"))
	}
	return nil
}

func (p *THBaseServiceIsTableDisabledArgs) readField1(iprot thrift.TProtocol) error {
	p.TableName = &TTableName{}
	if err := p.TableName.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TableName), err)
	}
	return nil
}

func (p *THBaseServiceIsTableDisabledArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("isTableDisabled_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceIsTableDisabledArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tableName: ", p), err)
	}
	if err := p.TableName.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TableName), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tableName: ", p), err)
	}
	return err
}

func (p *THBaseServiceIsTableDisabledArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceIsTableDisabledArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceIsTableDisabledResult struct {
	Success *bool     `thrift:"success,0" json:"success,omitempty"`
	Io      *TIOError `thrift:"io,1" json:"io,omitempty"`
}

func NewTHBaseServiceIsTableDisabledResult() *THBaseServiceIsTableDisabledResult {
	return &THBaseServiceIsTableDisabledResult{}
}

var THBaseServiceIsTableDisabledResult_Success_DEFAULT bool

func (p *THBaseServiceIsTableDisabledResult) GetSuccess() bool {
	if !p.IsSetSuccess() {
		return THBaseServiceIsTableDisabledResult_Success_DEFAULT
	}
	return *p.Success
}

var THBaseServiceIsTableDisabledResult_Io_DEFAULT *TIOError

func (p *THBaseServiceIsTableDisabledResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceIsTableDisabledResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceIsTableDisabledResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceIsTableDisabledResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceIsTableDisabledResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceIsTableDisabledResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return thrift.PrependError("error reading field 0: ", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *THBaseServiceIsTableDisabledResult) readField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceIsTableDisabledResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("isTableDisabled_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceIsTableDisabledResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.BOOL, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteBool(bool(*p.Success)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceIsTableDisabledResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceIsTableDisabledResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceIsTableDisabledResult(%+v)", *p)
}

// Attributes:
//  - TableName: the tablename to check
type THBaseServiceIsTableAvailableArgs struct {
	TableName *TTableName `thrift:"tableName,1,required" json:"tableName"`
}

func NewTHBaseServiceIsTableAvailableArgs() *THBaseServiceIsTableAvailableArgs {
	return &THBaseServiceIsTableAvailableArgs{}
}

var THBaseServiceIsTableAvailableArgs_TableName_DEFAULT *TTableName

func (p *THBaseServiceIsTableAvailableArgs) GetTableName() *TTableName {
	if !p.IsSetTableName() {
		return THBaseServiceIsTableAvailableArgs_TableName_DEFAULT
	}
	return p.TableName
}
func (p *THBaseServiceIsTableAvailableArgs) IsSetTableName() bool {
	return p.TableName != nil
}

func (p *THBaseServiceIsTableAvailableArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTableName bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetTableName = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTableName {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TableName is not set"))
	}
	return nil
}

func (p *THBaseServiceIsTableAvailableArgs) readField1(iprot thrift.TProtocol) error {
	p.TableName = &TTableName{}
	if err := p.TableName.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TableName), err)
	}
	return nil
}

func (p *THBaseServiceIsTableAvailableArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("isTableAvailable_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceIsTableAvailableArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tableName: ", p), err)
	}
	if err := p.TableName.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TableName), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tableName: ", p), err)
	}
	return err
}

func (p *THBaseServiceIsTableAvailableArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceIsTableAvailableArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceIsTableAvailableResult struct {
	Success *bool     `thrift:"success,0" json:"success,omitempty"`
	Io      *TIOError `thrift:"io,1" json:"io,omitempty"`
}

func NewTHBaseServiceIsTableAvailableResult() *THBaseServiceIsTableAvailableResult {
	return &THBaseServiceIsTableAvailableResult{}
}

var THBaseServiceIsTableAvailableResult_Success_DEFAULT bool

func (p *THBaseServiceIsTableAvailableResult) GetSuccess() bool {
	if !p.IsSetSuccess() {
		return THBaseServiceIsTableAvailableResult_Success_DEFAULT
	}
	return *p.Success
}

var THBaseServiceIsTableAvailableResult_Io_DEFAULT *TIOError

func (p *THBaseServiceIsTableAvailableResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceIsTableAvailableResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceIsTableAvailableResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceIsTableAvailableResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceIsTableAvailableResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceIsTableAvailableResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return thrift.PrependError("error reading field 0: ", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *THBaseServiceIsTableAvailableResult) readField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceIsTableAvailableResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("isTableAvailable_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceIsTableAvailableResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.BOOL, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteBool(bool(*p.Success)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceIsTableAvailableResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceIsTableAvailableResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceIsTableAvailableResult(%+v)", *p)
}

// Attributes:
//  - TableName: the tablename to check
//  - SplitKeys: keys to check if the table has been created with all split keys
type THBaseServiceIsTableAvailableWithSplitArgs struct {
	TableName *TTableName `thrift:"tableName,1,required" json:"tableName"`
	SplitKeys [][]byte    `thrift:"splitKeys,2" json:"splitKeys"`
}

func NewTHBaseServiceIsTableAvailableWithSplitArgs() *THBaseServiceIsTableAvailableWithSplitArgs {
	return &THBaseServiceIsTableAvailableWithSplitArgs{}
}

var THBaseServiceIsTableAvailableWithSplitArgs_TableName_DEFAULT *TTableName

func (p *THBaseServiceIsTableAvailableWithSplitArgs) GetTableName() *TTableName {
	if !p.IsSetTableName() {
		return THBaseServiceIsTableAvailableWithSplitArgs_TableName_DEFAULT
	}
	return p.TableName
}

func (p *THBaseServiceIsTableAvailableWithSplitArgs) GetSplitKeys() [][]byte {
	return p.SplitKeys
}
func (p *THBaseServiceIsTableAvailableWithSplitArgs) IsSetTableName() bool {
	return p.TableName != nil
}

func (p *THBaseServiceIsTableAvailableWithSplitArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTableName bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetTableName = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTableName {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TableName is not set"))
	}
	return nil
}

func (p *THBaseServiceIsTableAvailableWithSplitArgs) readField1(iprot thrift.TProtocol) error {
	p.TableName = &TTableName{}
	if err := p.TableName.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TableName), err)
	}
	return nil
}

func (p *THBaseServiceIsTableAvailableWithSplitArgs) readField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([][]byte, 0, size)
	p.SplitKeys = tSlice
	for i := 0; i < size; i++ {
		var _elem141 []byte
		if v, err := iprot.ReadBinary(); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem141 = v
		}
		p.SplitKeys = append(p.SplitKeys, _elem141)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *THBaseServiceIsTableAvailableWithSplitArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("isTableAvailableWithSplit_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceIsTableAvailableWithSplitArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tableName: ", p), err)
	}
	if err := p.TableName.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TableName), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tableName: ", p), err)
	}
	return err
}

func (p *THBaseServiceIsTableAvailableWithSplitArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("splitKeys", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:splitKeys: ", p), err)
	}
	if err := oprot.WriteListBegin(thrift.STRING, len(p.SplitKeys)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.SplitKeys {
		if err := oprot.WriteBinary(v); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:splitKeys: ", p), err)
	}
	return err
}

func (p *THBaseServiceIsTableAvailableWithSplitArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceIsTableAvailableWithSplitArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceIsTableAvailableWithSplitResult struct {
	Success *bool     `thrift:"success,0" json:"success,omitempty"`
	Io      *TIOError `thrift:"io,1" json:"io,omitempty"`
}

func NewTHBaseServiceIsTableAvailableWithSplitResult() *THBaseServiceIsTableAvailableWithSplitResult {
	return &THBaseServiceIsTableAvailableWithSplitResult{}
}

var THBaseServiceIsTableAvailableWithSplitResult_Success_DEFAULT bool

func (p *THBaseServiceIsTableAvailableWithSplitResult) GetSuccess() bool {
	if !p.IsSetSuccess() {
		return THBaseServiceIsTableAvailableWithSplitResult_Success_DEFAULT
	}
	return *p.Success
}

var THBaseServiceIsTableAvailableWithSplitResult_Io_DEFAULT *TIOError

func (p *THBaseServiceIsTableAvailableWithSplitResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceIsTableAvailableWithSplitResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceIsTableAvailableWithSplitResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceIsTableAvailableWithSplitResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceIsTableAvailableWithSplitResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceIsTableAvailableWithSplitResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return thrift.PrependError("error reading field 0: ", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *THBaseServiceIsTableAvailableWithSplitResult) readField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceIsTableAvailableWithSplitResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("isTableAvailableWithSplit_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceIsTableAvailableWithSplitResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.BOOL, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteBool(bool(*p.Success)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceIsTableAvailableWithSplitResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceIsTableAvailableWithSplitResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceIsTableAvailableWithSplitResult(%+v)", *p)
}

// Attributes:
//  - TableName: the tablename to add column family to
//  - Column: column family descriptor of column family to be added
type THBaseServiceAddColumnFamilyArgs struct {
	TableName *TTableName              `thrift:"tableName,1,required" json:"tableName"`
	Column    *TColumnFamilyDescriptor `thrift:"column,2,required" json:"column"`
}

func NewTHBaseServiceAddColumnFamilyArgs() *THBaseServiceAddColumnFamilyArgs {
	return &THBaseServiceAddColumnFamilyArgs{}
}

var THBaseServiceAddColumnFamilyArgs_TableName_DEFAULT *TTableName

func (p *THBaseServiceAddColumnFamilyArgs) GetTableName() *TTableName {
	if !p.IsSetTableName() {
		return THBaseServiceAddColumnFamilyArgs_TableName_DEFAULT
	}
	return p.TableName
}

var THBaseServiceAddColumnFamilyArgs_Column_DEFAULT *TColumnFamilyDescriptor

func (p *THBaseServiceAddColumnFamilyArgs) GetColumn() *TColumnFamilyDescriptor {
	if !p.IsSetColumn() {
		return THBaseServiceAddColumnFamilyArgs_Column_DEFAULT
	}
	return p.Column
}
func (p *THBaseServiceAddColumnFamilyArgs) IsSetTableName() bool {
	return p.TableName != nil
}

func (p *THBaseServiceAddColumnFamilyArgs) IsSetColumn() bool {
	return p.Column != nil
}

func (p *THBaseServiceAddColumnFamilyArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTableName bool = false
	var issetColumn bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetTableName = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetColumn = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTableName {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TableName is not set"))
	}
	if !issetColumn {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Column is not set"))
	}
	return nil
}

func (p *THBaseServiceAddColumnFamilyArgs) readField1(iprot thrift.TProtocol) error {
	p.TableName = &TTableName{}
	if err := p.TableName.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TableName), err)
	}
	return nil
}

func (p *THBaseServiceAddColumnFamilyArgs) readField2(iprot thrift.TProtocol) error {
	p.Column = &TColumnFamilyDescriptor{}
	if err := p.Column.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Column), err)
	}
	return nil
}

func (p *THBaseServiceAddColumnFamilyArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("addColumnFamily_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceAddColumnFamilyArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tableName: ", p), err)
	}
	if err := p.TableName.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TableName), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tableName: ", p), err)
	}
	return err
}

func (p *THBaseServiceAddColumnFamilyArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column", thrift.STRUCT, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:column: ", p), err)
	}
	if err := p.Column.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Column), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:column: ", p), err)
	}
	return err
}

func (p *THBaseServiceAddColumnFamilyArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceAddColumnFamilyArgs(%+v)", *p)
}

// Attributes:
//  - Io
type THBaseServiceAddColumnFamilyResult struct {
	Io *TIOError `thrift:"io,1" json:"io,omitempty"`
}

func NewTHBaseServiceAddColumnFamilyResult() *THBaseServiceAddColumnFamilyResult {
	return &THBaseServiceAddColumnFamilyResult{}
}

var THBaseServiceAddColumnFamilyResult_Io_DEFAULT *TIOError

func (p *THBaseServiceAddColumnFamilyResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceAddColumnFamilyResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceAddColumnFamilyResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceAddColumnFamilyResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceAddColumnFamilyResult) readField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceAddColumnFamilyResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("addColumnFamily_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceAddColumnFamilyResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceAddColumnFamilyResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceAddColumnFamilyResult(%+v)", *p)
}

// Attributes:
//  - TableName: the tablename to delete column family from
//  - Column: name of column family to be deleted
type THBaseServiceDeleteColumnFamilyArgs struct {
	TableName *TTableName `thrift:"tableName,1,required" json:"tableName"`
	Column    []byte      `thrift:"column,2,required" json:"column"`
}

func NewTHBaseServiceDeleteColumnFamilyArgs() *THBaseServiceDeleteColumnFamilyArgs {
	return &THBaseServiceDeleteColumnFamilyArgs{}
}

var THBaseServiceDeleteColumnFamilyArgs_TableName_DEFAULT *TTableName

func (p *THBaseServiceDeleteColumnFamilyArgs) GetTableName() *TTableName {
	if !p.IsSetTableName() {
		return THBaseServiceDeleteColumnFamilyArgs_TableName_DEFAULT
	}
	return p.TableName
}

func (p *THBaseServiceDeleteColumnFamilyArgs) GetColumn() []byte {
	return p.Column
}
func (p *THBaseServiceDeleteColumnFamilyArgs) IsSetTableName() bool {
	return p.TableName != nil
}

func (p *THBaseServiceDeleteColumnFamilyArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTableName bool = false
	var issetColumn bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetTableName = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetColumn = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTableName {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TableName is not set"))
	}
	if !issetColumn {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Column is not set"))
	}
	return nil
}

func (p *THBaseServiceDeleteColumnFamilyArgs) readField1(iprot thrift.TProtocol) error {
	p.TableName = &TTableName{}
	if err := p.TableName.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TableName), err)
	}
	return nil
}

func (p *THBaseServiceDeleteColumnFamilyArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Column = v
	}
	return nil
}

func (p *THBaseServiceDeleteColumnFamilyArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteColumnFamily_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceDeleteColumnFamilyArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tableName: ", p), err)
	}
	if err := p.TableName.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TableName), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tableName: ", p), err)
	}
	return err
}

func (p *THBaseServiceDeleteColumnFamilyArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:column: ", p), err)
	}
	if err := oprot.WriteBinary(p.Column); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.column (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:column: ", p), err)
	}
	return err
}

func (p *THBaseServiceDeleteColumnFamilyArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceDeleteColumnFamilyArgs(%+v)", *p)
}

// Attributes:
//  - Io
type THBaseServiceDeleteColumnFamilyResult struct {
	Io *TIOError `thrift:"io,1" json:"io,omitempty"`
}

func NewTHBaseServiceDeleteColumnFamilyResult() *THBaseServiceDeleteColumnFamilyResult {
	return &THBaseServiceDeleteColumnFamilyResult{}
}

var THBaseServiceDeleteColumnFamilyResult_Io_DEFAULT *TIOError

func (p *THBaseServiceDeleteColumnFamilyResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceDeleteColumnFamilyResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceDeleteColumnFamilyResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceDeleteColumnFamilyResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceDeleteColumnFamilyResult) readField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceDeleteColumnFamilyResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteColumnFamily_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceDeleteColumnFamilyResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceDeleteColumnFamilyResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceDeleteColumnFamilyResult(%+v)", *p)
}

// Attributes:
//  - TableName: the tablename to modify column family
//  - Column: column family descriptor of column family to be modified
type THBaseServiceModifyColumnFamilyArgs struct {
	TableName *TTableName              `thrift:"tableName,1,required" json:"tableName"`
	Column    *TColumnFamilyDescriptor `thrift:"column,2,required" json:"column"`
}

func NewTHBaseServiceModifyColumnFamilyArgs() *THBaseServiceModifyColumnFamilyArgs {
	return &THBaseServiceModifyColumnFamilyArgs{}
}

var THBaseServiceModifyColumnFamilyArgs_TableName_DEFAULT *TTableName

func (p *THBaseServiceModifyColumnFamilyArgs) GetTableName() *TTableName {
	if !p.IsSetTableName() {
		return THBaseServiceModifyColumnFamilyArgs_TableName_DEFAULT
	}
	return p.TableName
}

var THBaseServiceModifyColumnFamilyArgs_Column_DEFAULT *TColumnFamilyDescriptor

func (p *THBaseServiceModifyColumnFamilyArgs) GetColumn() *TColumnFamilyDescriptor {
	if !p.IsSetColumn() {
		return THBaseServiceModifyColumnFamilyArgs_Column_DEFAULT
	}
	return p.Column
}
func (p *THBaseServiceModifyColumnFamilyArgs) IsSetTableName() bool {
	return p.TableName != nil
}

func (p *THBaseServiceModifyColumnFamilyArgs) IsSetColumn() bool {
	return p.Column != nil
}

func (p *THBaseServiceModifyColumnFamilyArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTableName bool = false
	var issetColumn bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetTableName = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetColumn = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTableName {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TableName is not set"))
	}
	if !issetColumn {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Column is not set"))
	}
	return nil
}

func (p *THBaseServiceModifyColumnFamilyArgs) readField1(iprot thrift.TProtocol) error {
	p.TableName = &TTableName{}
	if err := p.TableName.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TableName), err)
	}
	return nil
}

func (p *THBaseServiceModifyColumnFamilyArgs) readField2(iprot thrift.TProtocol) error {
	p.Column = &TColumnFamilyDescriptor{}
	if err := p.Column.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Column), err)
	}
	return nil
}

func (p *THBaseServiceModifyColumnFamilyArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("modifyColumnFamily_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceModifyColumnFamilyArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tableName: ", p), err)
	}
	if err := p.TableName.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TableName), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tableName: ", p), err)
	}
	return err
}

func (p *THBaseServiceModifyColumnFamilyArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column", thrift.STRUCT, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:column: ", p), err)
	}
	if err := p.Column.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Column), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:column: ", p), err)
	}
	return err
}

func (p *THBaseServiceModifyColumnFamilyArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceModifyColumnFamilyArgs(%+v)", *p)
}

// Attributes:
//  - Io
type THBaseServiceModifyColumnFamilyResult struct {
	Io *TIOError `thrift:"io,1" json:"io,omitempty"`
}

func NewTHBaseServiceModifyColumnFamilyResult() *THBaseServiceModifyColumnFamilyResult {
	return &THBaseServiceModifyColumnFamilyResult{}
}

var THBaseServiceModifyColumnFamilyResult_Io_DEFAULT *TIOError

func (p *THBaseServiceModifyColumnFamilyResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceModifyColumnFamilyResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceModifyColumnFamilyResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceModifyColumnFamilyResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceModifyColumnFamilyResult) readField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceModifyColumnFamilyResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("modifyColumnFamily_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceModifyColumnFamilyResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceModifyColumnFamilyResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceModifyColumnFamilyResult(%+v)", *p)
}

// Attributes:
//  - Desc: the descriptor of the table to modify
type THBaseServiceModifyTableArgs struct {
	Desc *TTableDescriptor `thrift:"desc,1,required" json:"desc"`
}

func NewTHBaseServiceModifyTableArgs() *THBaseServiceModifyTableArgs {
	return &THBaseServiceModifyTableArgs{}
}

var THBaseServiceModifyTableArgs_Desc_DEFAULT *TTableDescriptor

func (p *THBaseServiceModifyTableArgs) GetDesc() *TTableDescriptor {
	if !p.IsSetDesc() {
		return THBaseServiceModifyTableArgs_Desc_DEFAULT
	}
	return p.Desc
}
func (p *THBaseServiceModifyTableArgs) IsSetDesc() bool {
	return p.Desc != nil
}

func (p *THBaseServiceModifyTableArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetDesc bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetDesc = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetDesc {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Desc is not set"))
	}
	return nil
}

func (p *THBaseServiceModifyTableArgs) readField1(iprot thrift.TProtocol) error {
	p.Desc = &TTableDescriptor{}
	if err := p.Desc.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Desc), err)
	}
	return nil
}

func (p *THBaseServiceModifyTableArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("modifyTable_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceModifyTableArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("desc", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:desc: ", p), err)
	}
	if err := p.Desc.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Desc), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:desc: ", p), err)
	}
	return err
}

func (p *THBaseServiceModifyTableArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceModifyTableArgs(%+v)", *p)
}

// Attributes:
//  - Io
type THBaseServiceModifyTableResult struct {
	Io *TIOError `thrift:"io,1" json:"io,omitempty"`
}

func NewTHBaseServiceModifyTableResult() *THBaseServiceModifyTableResult {
	return &THBaseServiceModifyTableResult{}
}

var THBaseServiceModifyTableResult_Io_DEFAULT *TIOError

func (p *THBaseServiceModifyTableResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceModifyTableResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceModifyTableResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceModifyTableResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceModifyTableResult) readField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceModifyTableResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("modifyTable_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceModifyTableResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceModifyTableResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceModifyTableResult(%+v)", *p)
}

// Attributes:
//  - NamespaceDesc: descriptor which describes the new namespace
type THBaseServiceCreateNamespaceArgs struct {
	NamespaceDesc *TNamespaceDescriptor `thrift:"namespaceDesc,1,required" json:"namespaceDesc"`
}

func NewTHBaseServiceCreateNamespaceArgs() *THBaseServiceCreateNamespaceArgs {
	return &THBaseServiceCreateNamespaceArgs{}
}

var THBaseServiceCreateNamespaceArgs_NamespaceDesc_DEFAULT *TNamespaceDescriptor

func (p *THBaseServiceCreateNamespaceArgs) GetNamespaceDesc() *TNamespaceDescriptor {
	if !p.IsSetNamespaceDesc() {
		return THBaseServiceCreateNamespaceArgs_NamespaceDesc_DEFAULT
	}
	return p.NamespaceDesc
}
func (p *THBaseServiceCreateNamespaceArgs) IsSetNamespaceDesc() bool {
	return p.NamespaceDesc != nil
}

func (p *THBaseServiceCreateNamespaceArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetNamespaceDesc bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetNamespaceDesc = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetNamespaceDesc {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field NamespaceDesc is not set"))
	}
	return nil
}

func (p *THBaseServiceCreateNamespaceArgs) readField1(iprot thrift.TProtocol) error {
	p.NamespaceDesc = &TNamespaceDescriptor{}
	if err := p.NamespaceDesc.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NamespaceDesc), err)
	}
	return nil
}

func (p *THBaseServiceCreateNamespaceArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("createNamespace_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceCreateNamespaceArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("namespaceDesc", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:namespaceDesc: ", p), err)
	}
	if err := p.NamespaceDesc.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NamespaceDesc), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:namespaceDesc: ", p), err)
	}
	return err
}

func (p *THBaseServiceCreateNamespaceArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceCreateNamespaceArgs(%+v)", *p)
}

// Attributes:
//  - Io
type THBaseServiceCreateNamespaceResult struct {
	Io *TIOError `thrift:"io,1" json:"io,omitempty"`
}

func NewTHBaseServiceCreateNamespaceResult() *THBaseServiceCreateNamespaceResult {
	return &THBaseServiceCreateNamespaceResult{}
}

var THBaseServiceCreateNamespaceResult_Io_DEFAULT *TIOError

func (p *THBaseServiceCreateNamespaceResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceCreateNamespaceResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceCreateNamespaceResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceCreateNamespaceResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceCreateNamespaceResult) readField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceCreateNamespaceResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("createNamespace_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceCreateNamespaceResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceCreateNamespaceResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceCreateNamespaceResult(%+v)", *p)
}

// Attributes:
//  - NamespaceDesc: descriptor which describes the new namespace
type THBaseServiceModifyNamespaceArgs struct {
	NamespaceDesc *TNamespaceDescriptor `thrift:"namespaceDesc,1,required" json:"namespaceDesc"`
}

func NewTHBaseServiceModifyNamespaceArgs() *THBaseServiceModifyNamespaceArgs {
	return &THBaseServiceModifyNamespaceArgs{}
}

var THBaseServiceModifyNamespaceArgs_NamespaceDesc_DEFAULT *TNamespaceDescriptor

func (p *THBaseServiceModifyNamespaceArgs) GetNamespaceDesc() *TNamespaceDescriptor {
	if !p.IsSetNamespaceDesc() {
		return THBaseServiceModifyNamespaceArgs_NamespaceDesc_DEFAULT
	}
	return p.NamespaceDesc
}
func (p *THBaseServiceModifyNamespaceArgs) IsSetNamespaceDesc() bool {
	return p.NamespaceDesc != nil
}

func (p *THBaseServiceModifyNamespaceArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetNamespaceDesc bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetNamespaceDesc = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetNamespaceDesc {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field NamespaceDesc is not set"))
	}
	return nil
}

func (p *THBaseServiceModifyNamespaceArgs) readField1(iprot thrift.TProtocol) error {
	p.NamespaceDesc = &TNamespaceDescriptor{}
	if err := p.NamespaceDesc.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NamespaceDesc), err)
	}
	return nil
}

func (p *THBaseServiceModifyNamespaceArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("modifyNamespace_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceModifyNamespaceArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("namespaceDesc", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:namespaceDesc: ", p), err)
	}
	if err := p.NamespaceDesc.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NamespaceDesc), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:namespaceDesc: ", p), err)
	}
	return err
}

func (p *THBaseServiceModifyNamespaceArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceModifyNamespaceArgs(%+v)", *p)
}

// Attributes:
//  - Io
type THBaseServiceModifyNamespaceResult struct {
	Io *TIOError `thrift:"io,1" json:"io,omitempty"`
}

func NewTHBaseServiceModifyNamespaceResult() *THBaseServiceModifyNamespaceResult {
	return &THBaseServiceModifyNamespaceResult{}
}

var THBaseServiceModifyNamespaceResult_Io_DEFAULT *TIOError

func (p *THBaseServiceModifyNamespaceResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceModifyNamespaceResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceModifyNamespaceResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceModifyNamespaceResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceModifyNamespaceResult) readField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceModifyNamespaceResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("modifyNamespace_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceModifyNamespaceResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceModifyNamespaceResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceModifyNamespaceResult(%+v)", *p)
}

// Attributes:
//  - Name: namespace name
type THBaseServiceDeleteNamespaceArgs struct {
	Name string `thrift:"name,1,required" json:"name"`
}

func NewTHBaseServiceDeleteNamespaceArgs() *THBaseServiceDeleteNamespaceArgs {
	return &THBaseServiceDeleteNamespaceArgs{}
}

func (p *THBaseServiceDeleteNamespaceArgs) GetName() string {
	return p.Name
}
func (p *THBaseServiceDeleteNamespaceArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetName bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetName = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetName {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Name is not set"))
	}
	return nil
}

func (p *THBaseServiceDeleteNamespaceArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Name = v
	}
	return nil
}

func (p *THBaseServiceDeleteNamespaceArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteNamespace_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceDeleteNamespaceArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err)
	}
	if err := oprot.WriteString(string(p.Name)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.name (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err)
	}
	return err
}

func (p *THBaseServiceDeleteNamespaceArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceDeleteNamespaceArgs(%+v)", *p)
}

// Attributes:
//  - Io
type THBaseServiceDeleteNamespaceResult struct {
	Io *TIOError `thrift:"io,1" json:"io,omitempty"`
}

func NewTHBaseServiceDeleteNamespaceResult() *THBaseServiceDeleteNamespaceResult {
	return &THBaseServiceDeleteNamespaceResult{}
}

var THBaseServiceDeleteNamespaceResult_Io_DEFAULT *TIOError

func (p *THBaseServiceDeleteNamespaceResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceDeleteNamespaceResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceDeleteNamespaceResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceDeleteNamespaceResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceDeleteNamespaceResult) readField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceDeleteNamespaceResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteNamespace_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceDeleteNamespaceResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceDeleteNamespaceResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceDeleteNamespaceResult(%+v)", *p)
}

// Attributes:
//  - Name: name of namespace descriptor
type THBaseServiceGetNamespaceDescriptorArgs struct {
	Name string `thrift:"name,1,required" json:"name"`
}

func NewTHBaseServiceGetNamespaceDescriptorArgs() *THBaseServiceGetNamespaceDescriptorArgs {
	return &THBaseServiceGetNamespaceDescriptorArgs{}
}

func (p *THBaseServiceGetNamespaceDescriptorArgs) GetName() string {
	return p.Name
}
func (p *THBaseServiceGetNamespaceDescriptorArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetName bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetName = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetName {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Name is not set"))
	}
	return nil
}

func (p *THBaseServiceGetNamespaceDescriptorArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Name = v
	}
	return nil
}

func (p *THBaseServiceGetNamespaceDescriptorArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getNamespaceDescriptor_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceGetNamespaceDescriptorArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err)
	}
	if err := oprot.WriteString(string(p.Name)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.name (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err)
	}
	return err
}

func (p *THBaseServiceGetNamespaceDescriptorArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceGetNamespaceDescriptorArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceGetNamespaceDescriptorResult struct {
	Success *TNamespaceDescriptor `thrift:"success,0" json:"success,omitempty"`
	Io      *TIOError             `thrift:"io,1" json:"io,omitempty"`
}

func NewTHBaseServiceGetNamespaceDescriptorResult() *THBaseServiceGetNamespaceDescriptorResult {
	return &THBaseServiceGetNamespaceDescriptorResult{}
}

var THBaseServiceGetNamespaceDescriptorResult_Success_DEFAULT *TNamespaceDescriptor

func (p *THBaseServiceGetNamespaceDescriptorResult) GetSuccess() *TNamespaceDescriptor {
	if !p.IsSetSuccess() {
		return THBaseServiceGetNamespaceDescriptorResult_Success_DEFAULT
	}
	return p.Success
}

var THBaseServiceGetNamespaceDescriptorResult_Io_DEFAULT *TIOError

func (p *THBaseServiceGetNamespaceDescriptorResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceGetNamespaceDescriptorResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceGetNamespaceDescriptorResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceGetNamespaceDescriptorResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceGetNamespaceDescriptorResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceGetNamespaceDescriptorResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &TNamespaceDescriptor{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *THBaseServiceGetNamespaceDescriptorResult) readField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceGetNamespaceDescriptorResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getNamespaceDescriptor_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceGetNamespaceDescriptorResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceGetNamespaceDescriptorResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceGetNamespaceDescriptorResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceGetNamespaceDescriptorResult(%+v)", *p)
}

type THBaseServiceListNamespaceDescriptorsArgs struct {
}

func NewTHBaseServiceListNamespaceDescriptorsArgs() *THBaseServiceListNamespaceDescriptorsArgs {
	return &THBaseServiceListNamespaceDescriptorsArgs{}
}

func (p *THBaseServiceListNamespaceDescriptorsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceListNamespaceDescriptorsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("listNamespaceDescriptors_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceListNamespaceDescriptorsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceListNamespaceDescriptorsArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Io
type THBaseServiceListNamespaceDescriptorsResult struct {
	Success []*TNamespaceDescriptor `thrift:"success,0" json:"success,omitempty"`
	Io      *TIOError               `thrift:"io,1" json:"io,omitempty"`
}

func NewTHBaseServiceListNamespaceDescriptorsResult() *THBaseServiceListNamespaceDescriptorsResult {
	return &THBaseServiceListNamespaceDescriptorsResult{}
}

var THBaseServiceListNamespaceDescriptorsResult_Success_DEFAULT []*TNamespaceDescriptor

func (p *THBaseServiceListNamespaceDescriptorsResult) GetSuccess() []*TNamespaceDescriptor {
	return p.Success
}

var THBaseServiceListNamespaceDescriptorsResult_Io_DEFAULT *TIOError

func (p *THBaseServiceListNamespaceDescriptorsResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return THBaseServiceListNamespaceDescriptorsResult_Io_DEFAULT
	}
	return p.Io
}
func (p *THBaseServiceListNamespaceDescriptorsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *THBaseServiceListNamespaceDescriptorsResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *THBaseServiceListNamespaceDescriptorsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *THBaseServiceListNamespaceDescriptorsResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*TNamespaceDescriptor, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem142 := &TNamespaceDescriptor{}
		if err := _elem142.Read(iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem142), err)
		}
		p.Success = append(p.Success, _elem142)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *THBaseServiceListNamespaceDescriptorsResult) readField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Io), err)
	}
	return nil
}

func (p *THBaseServiceListNamespaceDescriptorsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("listNamespaceDescriptors_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *THBaseServiceListNamespaceDescriptorsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceListNamespaceDescriptorsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:io: ", p), err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Io), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:io: ", p), err)
		}
	}
	return err
}

func (p *THBaseServiceListNamespaceDescriptorsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("THBaseServiceListNamespaceDescriptorsResult(%+v)", *p)
}
